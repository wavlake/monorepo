
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/wavlake/monorepo/internal/auth/dual.go (15.7%)</option>
				
				<option value="file1">github.com/wavlake/monorepo/internal/auth/firebase.go (68.2%)</option>
				
				<option value="file2">github.com/wavlake/monorepo/internal/auth/firebase_link_guard.go (0.0%)</option>
				
				<option value="file3">github.com/wavlake/monorepo/internal/auth/flexible.go (0.0%)</option>
				
				<option value="file4">github.com/wavlake/monorepo/internal/auth/nip98.go (4.1%)</option>
				
				<option value="file5">github.com/wavlake/monorepo/internal/config/dev.go (0.0%)</option>
				
				<option value="file6">github.com/wavlake/monorepo/internal/config/service_config.go (0.0%)</option>
				
				<option value="file7">github.com/wavlake/monorepo/internal/handlers/auth.go (100.0%)</option>
				
				<option value="file8">github.com/wavlake/monorepo/internal/handlers/auth_token_handler.go (82.9%)</option>
				
				<option value="file9">github.com/wavlake/monorepo/internal/handlers/development_handler.go (20.6%)</option>
				
				<option value="file10">github.com/wavlake/monorepo/internal/handlers/file_server_handler.go (0.0%)</option>
				
				<option value="file11">github.com/wavlake/monorepo/internal/handlers/heartbeat.go (0.0%)</option>
				
				<option value="file12">github.com/wavlake/monorepo/internal/handlers/legacy_handler.go (97.6%)</option>
				
				<option value="file13">github.com/wavlake/monorepo/internal/handlers/mock_storage_handler.go (0.0%)</option>
				
				<option value="file14">github.com/wavlake/monorepo/internal/handlers/tracks.go (100.0%)</option>
				
				<option value="file15">github.com/wavlake/monorepo/internal/handlers/webhook_handler.go (0.0%)</option>
				
				<option value="file16">github.com/wavlake/monorepo/internal/middleware/logging.go (100.0%)</option>
				
				<option value="file17">github.com/wavlake/monorepo/internal/services/compression_service.go (96.9%)</option>
				
				<option value="file18">github.com/wavlake/monorepo/internal/services/development_service.go (0.0%)</option>
				
				<option value="file19">github.com/wavlake/monorepo/internal/services/file_server_service.go (0.0%)</option>
				
				<option value="file20">github.com/wavlake/monorepo/internal/services/mock_storage_service.go (0.0%)</option>
				
				<option value="file21">github.com/wavlake/monorepo/internal/services/nostr_track.go (0.0%)</option>
				
				<option value="file22">github.com/wavlake/monorepo/internal/services/postgres_service.go (0.0%)</option>
				
				<option value="file23">github.com/wavlake/monorepo/internal/services/processing.go (0.0%)</option>
				
				<option value="file24">github.com/wavlake/monorepo/internal/services/storage.go (0.0%)</option>
				
				<option value="file25">github.com/wavlake/monorepo/internal/services/token_service.go (0.0%)</option>
				
				<option value="file26">github.com/wavlake/monorepo/internal/services/user_service.go (0.0%)</option>
				
				<option value="file27">github.com/wavlake/monorepo/internal/services/webhook_service.go (0.0%)</option>
				
				<option value="file28">github.com/wavlake/monorepo/internal/utils/audio.go (0.0%)</option>
				
				<option value="file29">github.com/wavlake/monorepo/internal/utils/storage_paths.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "firebase.google.com/go/v4/auth"
        "github.com/gin-gonic/gin"
        gonostr "github.com/nbd-wtf/go-nostr"
        "github.com/wavlake/monorepo/pkg/nostr"
)

type DualAuthMiddleware struct {
        firebaseAuth *auth.Client
}

func NewDualAuthMiddleware(firebaseAuth *auth.Client) *DualAuthMiddleware <span class="cov8" title="1">{
        return &amp;DualAuthMiddleware{
                firebaseAuth: firebaseAuth,
        }
}</span>

func (m *DualAuthMiddleware) Middleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // 1. Validate Firebase token
                firebaseToken := extractBearerToken(c.GetHeader("Authorization"))
                if firebaseToken == "" </span><span class="cov8" title="1">{
                        // Also check X-Firebase-Token header
                        firebaseToken = c.GetHeader("X-Firebase-Token")
                }</span>
                <span class="cov8" title="1">if firebaseToken == "" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Firebase authorization token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">firebaseUser, err := m.firebaseAuth.VerifyIDToken(context.Background(), firebaseToken)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid Firebase token"})
                        c.Abort()
                        return
                }</span>

                // 2. Validate NIP-98 signature
                <span class="cov0" title="0">nip98Event, err := m.validateNIP98(c.Request)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": fmt.Sprintf("Invalid NIP-98 signature: %v", err)})
                        c.Abort()
                        return
                }</span>

                // 3. Store both auth contexts
                <span class="cov0" title="0">c.Set("firebase_uid", firebaseUser.UID)
                if email, ok := firebaseUser.Claims["email"].(string); ok </span><span class="cov0" title="0">{
                        c.Set("firebase_email", email)
                }</span>
                <span class="cov0" title="0">c.Set("nostr_pubkey", nip98Event.PubKey)
                c.Next()</span>
        }
}

func (m *DualAuthMiddleware) validateNIP98(r *http.Request) (*nostr.Event, error) <span class="cov0" title="0">{
        // Check for Nostr authorization header
        nostrHeader := r.Header.Get("X-Nostr-Authorization")
        if nostrHeader == "" </span><span class="cov0" title="0">{
                // Also check Authorization header for Nostr scheme
                authHeader := r.Header.Get("Authorization")
                if strings.HasPrefix(authHeader, "Nostr ") </span><span class="cov0" title="0">{
                        nostrHeader = authHeader
                }</span>
        }
        <span class="cov0" title="0">if nostrHeader == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing Nostr authorization header")
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(nostrHeader, "Nostr ") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid Nostr authorization scheme")
        }</span>

        <span class="cov0" title="0">encodedEvent := strings.TrimPrefix(nostrHeader, "Nostr ")
        eventData, err := base64.StdEncoding.DecodeString(encodedEvent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid base64 encoding: %w", err)
        }</span>

        <span class="cov0" title="0">var gonostrEvent gonostr.Event
        if err := json.Unmarshal(eventData, &amp;gonostrEvent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid event JSON: %w", err)
        }</span>

        <span class="cov0" title="0">event := &amp;nostr.Event{Event: &amp;gonostrEvent}

        // Validate NIP-98 requirements
        if event.Kind != 27235 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid event kind: expected 27235, got %d", event.Kind)
        }</span>

        <span class="cov0" title="0">now := time.Now().Unix()
        createdAt := int64(event.CreatedAt)
        if now-createdAt &gt; 60 || createdAt &gt; now+60 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("event timestamp out of range")
        }</span>

        <span class="cov0" title="0">var urlTag, methodTag string
        for _, tag := range event.Tags </span><span class="cov0" title="0">{
                if len(tag) &gt;= 2 </span><span class="cov0" title="0">{
                        switch tag[0] </span>{
                        case "u":<span class="cov0" title="0">
                                urlTag = tag[1]</span>
                        case "method":<span class="cov0" title="0">
                                methodTag = tag[1]</span>
                        }
                }
        }

        <span class="cov0" title="0">scheme := "http"
        if r.TLS != nil </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>
        // Check X-Forwarded-Proto header for proxy/load balancer setups (like Cloud Run)
        <span class="cov0" title="0">if proto := r.Header.Get("X-Forwarded-Proto"); proto == "https" </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>
        <span class="cov0" title="0">fullURL := fmt.Sprintf("%s://%s%s", scheme, r.Host, r.RequestURI)

        log.Printf("NIP-98 Debug - URL check: fullURL='%s', urlTag='%s'", fullURL, urlTag)
        if urlTag != fullURL </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("URL mismatch: expected %s, got %s", fullURL, urlTag)
        }</span>

        <span class="cov0" title="0">log.Printf("NIP-98 Debug - Method check: method='%s', methodTag='%s'", r.Method, methodTag)
        if methodTag != r.Method </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("method mismatch: expected %s, got %s", r.Method, methodTag)
        }</span>

        <span class="cov0" title="0">log.Printf("NIP-98 Debug - About to verify signature for event ID: %s", event.ID)
        if !event.Verify() </span><span class="cov0" title="0">{
                log.Printf("NIP-98 Debug - Signature verification failed for event: %+v", event)
                return nil, fmt.Errorf("invalid event signature")
        }</span>

        <span class="cov0" title="0">return event, nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "context"
        "net/http"
        "strings"

        "firebase.google.com/go/v4/auth"
        "github.com/gin-gonic/gin"
)

type FirebaseMiddleware struct {
        authClient *auth.Client
}

func NewFirebaseMiddleware(authClient *auth.Client) *FirebaseMiddleware <span class="cov8" title="1">{
        return &amp;FirebaseMiddleware{
                authClient: authClient,
        }
}</span>

func (m *FirebaseMiddleware) Middleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                token := extractBearerToken(c.GetHeader("Authorization"))
                if token == "" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authorization token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov8" title="1">firebaseToken, err := m.authClient.VerifyIDToken(context.Background(), token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid Firebase token"})
                        c.Abort()
                        return
                }</span>

                // Store Firebase user info in context
                <span class="cov0" title="0">c.Set("firebase_uid", firebaseToken.UID)
                if email, ok := firebaseToken.Claims["email"].(string); ok </span><span class="cov0" title="0">{
                        c.Set("firebase_email", email)
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}

func extractBearerToken(authHeader string) string <span class="cov8" title="1">{
        if authHeader == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return parts[1]</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "context"
        "fmt"
        "log"
        "net/http"

        "cloud.google.com/go/firestore"
        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "google.golang.org/api/iterator"
)

// FirebaseLinkGuard ensures that a pubkey is linked to a Firebase UID
type FirebaseLinkGuard struct {
        firestoreClient *firestore.Client
}

// NewFirebaseLinkGuard creates a new Firebase link guard middleware
func NewFirebaseLinkGuard(firestoreClient *firestore.Client) *FirebaseLinkGuard <span class="cov0" title="0">{
        return &amp;FirebaseLinkGuard{
                firestoreClient: firestoreClient,
        }
}</span>

// Middleware checks if the authenticated pubkey is linked to a Firebase UID
// This middleware should be used after NIP-98 signature validation middleware
func (g *FirebaseLinkGuard) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get the pubkey from context (should be set by NIP-98 middleware)
                pubkey, exists := c.Get("pubkey")
                if !exists || pubkey == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing pubkey in context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">pubkeyStr, ok := pubkey.(string)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid pubkey format"})
                        c.Abort()
                        return
                }</span>

                // Check if pubkey is linked to a Firebase UID
                <span class="cov0" title="0">ctx := context.Background()
                auth, err := g.getNostrAuth(ctx, pubkeyStr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Firebase link check failed for pubkey %s: %v", pubkeyStr, err)
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "User is not authorized. Please link your Nostr identity to your Firebase account to access this feature.",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !auth.Active </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "User is not authorized. Account is inactive.",
                        })
                        c.Abort()
                        return
                }</span>

                // Set firebase_uid in context for downstream handlers
                <span class="cov0" title="0">c.Set("firebase_uid", auth.FirebaseUID)
                c.Next()</span>
        }
}

// getNostrAuth retrieves NostrAuth record for the given pubkey
func (g *FirebaseLinkGuard) getNostrAuth(ctx context.Context, pubkey string) (*models.NostrAuth, error) <span class="cov0" title="0">{
        query := g.firestoreClient.Collection("nostr_auth").Where("pubkey", "==", pubkey).Where("active", "==", true).Limit(1)
        iter := query.Documents(ctx)
        defer iter.Stop()

        doc, err := iter.Next()
        if err == iterator.Done </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubkey not linked to Firebase UID")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var auth models.NostrAuth
        if err := doc.DataTo(&amp;auth); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;auth, nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        "firebase.google.com/go/v4/auth"
        "github.com/gin-gonic/gin"
        gonostr "github.com/nbd-wtf/go-nostr"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/pkg/nostr"
        "google.golang.org/api/iterator"
)

// NIP98AuthResult represents the result of NIP-98 authentication attempt
type NIP98AuthResult struct {
        Success     bool
        FirebaseUID string
        ErrorType   string
        ErrorMsg    string
}

// FlexibleAuthMiddleware provides authentication via Firebase Bearer token or NIP-98 signature
// with graceful fallback between the two methods
type FlexibleAuthMiddleware struct {
        firebaseAuth    *auth.Client
        firestoreClient *firestore.Client
}

// NewFlexibleAuthMiddleware creates a new flexible authentication middleware
func NewFlexibleAuthMiddleware(firebaseAuth *auth.Client, firestoreClient *firestore.Client) *FlexibleAuthMiddleware <span class="cov0" title="0">{
        return &amp;FlexibleAuthMiddleware{
                firebaseAuth:    firebaseAuth,
                firestoreClient: firestoreClient,
        }
}</span>

// Middleware returns the Gin middleware handler that tries Firebase auth first, then NIP-98
func (m *FlexibleAuthMiddleware) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip heartbeat endpoint
                if c.Request.URL.Path == "/heartbeat" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // First try Firebase Bearer token authentication
                <span class="cov0" title="0">if firebaseUID := m.tryFirebaseAuth(c); firebaseUID != "" </span><span class="cov0" title="0">{
                        // Firebase auth successful
                        c.Set("firebase_uid", firebaseUID)
                        c.Set("auth_method", "firebase")
                        c.Next()
                        return
                }</span>

                // Firebase failed, try NIP-98 signature authentication
                <span class="cov0" title="0">nip98Result := m.tryNIP98Auth(c)
                if nip98Result.Success </span><span class="cov0" title="0">{
                        // NIP-98 auth successful
                        c.Set("firebase_uid", nip98Result.FirebaseUID)
                        c.Set("auth_method", "nip98")
                        c.Next()
                        return
                }</span>

                // Both authentication methods failed - provide specific error message
                <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, gin.H{
                        "error": nip98Result.ErrorMsg,
                })
                c.Abort()</span>
        }
}

// tryFirebaseAuth attempts to authenticate using Firebase Bearer token
// Returns firebase_uid on success, empty string on failure
func (m *FlexibleAuthMiddleware) tryFirebaseAuth(c *gin.Context) string <span class="cov0" title="0">{
        // Extract Bearer token from Authorization header
        token := extractBearerToken(c.GetHeader("Authorization"))
        if token == "" </span><span class="cov0" title="0">{
                // Also check X-Firebase-Token header
                token = c.GetHeader("X-Firebase-Token")
        }</span>
        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Verify Firebase token
        <span class="cov0" title="0">firebaseToken, err := m.firebaseAuth.VerifyIDToken(context.Background(), token)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Firebase token verification failed: %v", err)
                return ""
        }</span>

        // Store additional Firebase user info in context
        <span class="cov0" title="0">if email, ok := firebaseToken.Claims["email"].(string); ok </span><span class="cov0" title="0">{
                c.Set("firebase_email", email)
        }</span>

        <span class="cov0" title="0">return firebaseToken.UID</span>
}

// tryNIP98Auth attempts to authenticate using NIP-98 signature
// Returns detailed result with success status and specific error information
func (m *FlexibleAuthMiddleware) tryNIP98Auth(c *gin.Context) NIP98AuthResult <span class="cov0" title="0">{
        // First validate the NIP-98 signature
        pubkey := m.validateNIP98Signature(c.Request)
        if pubkey == "" </span><span class="cov0" title="0">{
                return NIP98AuthResult{
                        Success:   false,
                        ErrorType: "invalid_signature",
                        ErrorMsg:  "Invalid or missing NIP-98 signature",
                }
        }</span>

        // Look up the linked Firebase UID for this pubkey
        <span class="cov0" title="0">ctx := context.Background()
        auth, err := m.getNostrAuth(ctx, pubkey)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get auth for pubkey %s: %v", pubkey, err)
                if err.Error() == "pubkey not found" </span><span class="cov0" title="0">{
                        return NIP98AuthResult{
                                Success:   false,
                                ErrorType: "pubkey_not_linked",
                                ErrorMsg:  "Nostr pubkey not linked to Firebase account. Please link your pubkey first.",
                        }
                }</span>
                <span class="cov0" title="0">return NIP98AuthResult{
                        Success:   false,
                        ErrorType: "database_error",
                        ErrorMsg:  "Failed to verify account linking",
                }</span>
        }

        <span class="cov0" title="0">if !auth.Active </span><span class="cov0" title="0">{
                log.Printf("Account inactive for pubkey %s", pubkey)
                return NIP98AuthResult{
                        Success:   false,
                        ErrorType: "account_inactive",
                        ErrorMsg:  "Account is inactive",
                }
        }</span>

        // Store NIP-98 specific context
        <span class="cov0" title="0">c.Set("nostr_pubkey", pubkey)

        // Update last used timestamp in background
        go m.updateLastUsed(context.Background(), pubkey)

        return NIP98AuthResult{
                Success:     true,
                FirebaseUID: auth.FirebaseUID,
        }</span>
}

// validateNIP98Signature validates the NIP-98 signature and returns the pubkey
// Returns empty string if validation fails
func (m *FlexibleAuthMiddleware) validateNIP98Signature(r *http.Request) string <span class="cov0" title="0">{
        // Check for Nostr authorization header
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Must be "Nostr " scheme
        <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Nostr ") </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Decode the base64 event
        <span class="cov0" title="0">encodedEvent := strings.TrimPrefix(authHeader, "Nostr ")
        eventData, err := base64.StdEncoding.DecodeString(encodedEvent)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid base64 encoding in NIP-98 auth: %v", err)
                return ""
        }</span>

        // Parse the event
        <span class="cov0" title="0">var gonostrEvent gonostr.Event
        if err := json.Unmarshal(eventData, &amp;gonostrEvent); err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid event JSON in NIP-98 auth: %v", err)
                return ""
        }</span>

        <span class="cov0" title="0">event := &amp;nostr.Event{Event: &amp;gonostrEvent}

        // Validate NIP-98 requirements
        if event.Kind != 27235 </span><span class="cov0" title="0">{
                log.Printf("Invalid event kind in NIP-98 auth: expected 27235, got %d", event.Kind)
                return ""
        }</span>

        // Check timestamp (must be within 60 seconds)
        <span class="cov0" title="0">now := time.Now().Unix()
        createdAt := int64(event.CreatedAt)
        if now-createdAt &gt; 60 || createdAt &gt; now+60 </span><span class="cov0" title="0">{
                log.Printf("Event timestamp out of range in NIP-98 auth: now=%d, created_at=%d", now, createdAt)
                return ""
        }</span>

        // Validate URL and method tags
        <span class="cov0" title="0">var urlTag, methodTag string
        for _, tag := range event.Tags </span><span class="cov0" title="0">{
                if len(tag) &gt;= 2 </span><span class="cov0" title="0">{
                        switch tag[0] </span>{
                        case "u":<span class="cov0" title="0">
                                urlTag = tag[1]</span>
                        case "method":<span class="cov0" title="0">
                                methodTag = tag[1]</span>
                        }
                }
        }

        // Construct the expected URL
        <span class="cov0" title="0">scheme := "http"
        if r.TLS != nil </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>
        // Check X-Forwarded-Proto header for proxy/load balancer setups (like Cloud Run)
        <span class="cov0" title="0">if proto := r.Header.Get("X-Forwarded-Proto"); proto == "https" </span><span class="cov0" title="0">{
                scheme = "https"
        }</span>
        <span class="cov0" title="0">fullURL := fmt.Sprintf("%s://%s%s", scheme, r.Host, r.RequestURI)

        if urlTag != fullURL </span><span class="cov0" title="0">{
                log.Printf("URL mismatch in NIP-98 auth: expected %s, got %s", fullURL, urlTag)
                return ""
        }</span>

        <span class="cov0" title="0">if methodTag != r.Method </span><span class="cov0" title="0">{
                log.Printf("Method mismatch in NIP-98 auth: expected %s, got %s", r.Method, methodTag)
                return ""
        }</span>

        // Verify the signature
        <span class="cov0" title="0">if !event.Verify() </span><span class="cov0" title="0">{
                log.Printf("Invalid event signature in NIP-98 auth")
                return ""
        }</span>

        <span class="cov0" title="0">return event.PubKey</span>
}

// getNostrAuth retrieves the NostrAuth record for a given pubkey
func (m *FlexibleAuthMiddleware) getNostrAuth(ctx context.Context, pubkey string) (*models.NostrAuth, error) <span class="cov0" title="0">{
        query := m.firestoreClient.Collection("nostr_auth").Where("pubkey", "==", pubkey).Where("active", "==", true).Limit(1)
        iter := query.Documents(ctx)
        defer iter.Stop()

        doc, err := iter.Next()
        if err == iterator.Done </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubkey not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var auth models.NostrAuth
        if err := doc.DataTo(&amp;auth); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;auth, nil</span>
}

// updateLastUsed updates the last_used_at timestamp for a pubkey
func (m *FlexibleAuthMiddleware) updateLastUsed(ctx context.Context, pubkey string) <span class="cov0" title="0">{
        query := m.firestoreClient.Collection("nostr_auth").Where("pubkey", "==", pubkey).Limit(1)
        iter := query.Documents(ctx)
        defer iter.Stop()

        doc, err := iter.Next()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to find document for last_used_at update: %v", err)
                return
        }</span>

        <span class="cov0" title="0">_, err = doc.Ref.Update(ctx, []firestore.Update{
                {Path: "last_used_at", Value: time.Now()},
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update last_used_at for pubkey %s: %v", pubkey, err)
        }</span>
}

// GetAuthMethod returns the authentication method used for the current request
func GetAuthMethod(c *gin.Context) string <span class="cov0" title="0">{
        if method, exists := c.Get("auth_method"); exists </span><span class="cov0" title="0">{
                return method.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IsFirebaseAuth returns true if the request was authenticated via Firebase
func IsFirebaseAuth(c *gin.Context) bool <span class="cov0" title="0">{
        return GetAuthMethod(c) == "firebase"
}</span>

// IsNIP98Auth returns true if the request was authenticated via NIP-98
func IsNIP98Auth(c *gin.Context) bool <span class="cov0" title="0">{
        return GetAuthMethod(c) == "nip98"
}</span>

// GetNostrPubkey returns the Nostr pubkey if authenticated via NIP-98
func GetNostrPubkey(c *gin.Context) string <span class="cov0" title="0">{
        if pubkey, exists := c.Get("nostr_pubkey"); exists </span><span class="cov0" title="0">{
                return pubkey.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetFirebaseUID returns the Firebase UID (available for both auth methods)
func GetFirebaseUID(c *gin.Context) string <span class="cov0" title="0">{
        if uid, exists := c.Get("firebase_uid"); exists </span><span class="cov0" title="0">{
                return uid.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetFirebaseEmail returns the Firebase email (only available for Firebase auth)
func GetFirebaseEmail(c *gin.Context) string <span class="cov0" title="0">{
        if email, exists := c.Get("firebase_email"); exists </span><span class="cov0" title="0">{
                return email.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "cloud.google.com/go/firestore"
        gonostr "github.com/nbd-wtf/go-nostr"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/pkg/nostr"
        "google.golang.org/api/iterator"
)

type NIP98Middleware struct {
        firestoreClient *firestore.Client
}

func NewNIP98Middleware(ctx context.Context, projectID string) (*NIP98Middleware, error) <span class="cov8" title="1">{
        client, err := firestore.NewClient(ctx, projectID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create firestore client: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;NIP98Middleware{
                firestoreClient: client,
        }, nil</span>
}

func (m *NIP98Middleware) Close() error <span class="cov0" title="0">{
        return m.firestoreClient.Close()
}</span>

// SignatureValidationMiddleware validates NIP-98 signatures without database lookup
func (m *NIP98Middleware) SignatureValidationMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/heartbeat" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Missing Authorization header", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Nostr ") </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid Authorization scheme", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">encodedEvent := strings.TrimPrefix(authHeader, "Nostr ")
                eventData, err := base64.StdEncoding.DecodeString(encodedEvent)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid base64 encoding", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">var gonostrEvent gonostr.Event
                if err := json.Unmarshal(eventData, &amp;gonostrEvent); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid event JSON", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">event := &amp;nostr.Event{Event: &amp;gonostrEvent}

                if event.Kind != 27235 </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid event kind", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">now := time.Now().Unix()
                createdAt := int64(event.CreatedAt)
                if now-createdAt &gt; 60 || createdAt &gt; now+60 </span><span class="cov0" title="0">{
                        http.Error(w, "Event timestamp out of range", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">var urlTag, methodTag string
                for _, tag := range event.Tags </span><span class="cov0" title="0">{
                        if len(tag) &gt;= 2 </span><span class="cov0" title="0">{
                                switch tag[0] </span>{
                                case "u":<span class="cov0" title="0">
                                        urlTag = tag[1]</span>
                                case "method":<span class="cov0" title="0">
                                        methodTag = tag[1]</span>
                                }
                        }
                }

                <span class="cov0" title="0">scheme := "http"
                if r.TLS != nil </span><span class="cov0" title="0">{
                        scheme = "https"
                }</span>
                // Check X-Forwarded-Proto header for proxy/load balancer setups (like Cloud Run)
                <span class="cov0" title="0">if proto := r.Header.Get("X-Forwarded-Proto"); proto == "https" </span><span class="cov0" title="0">{
                        scheme = "https"
                }</span>
                <span class="cov0" title="0">fullURL := fmt.Sprintf("%s://%s%s", scheme, r.Host, r.RequestURI)

                if urlTag != fullURL </span><span class="cov0" title="0">{
                        log.Printf("URL mismatch: expected %s, got %s", fullURL, urlTag)
                        http.Error(w, "URL mismatch", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if methodTag != r.Method </span><span class="cov0" title="0">{
                        http.Error(w, "Method mismatch", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if !event.Verify() </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid event signature", http.StatusUnauthorized)
                        return
                }</span>

                // Only set the pubkey in context, no database lookup
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "pubkey", event.PubKey)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// DatabaseLookupMiddleware performs database lookup for authenticated pubkey
func (m *NIP98Middleware) DatabaseLookupMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Get the pubkey from context (should be set by SignatureValidationMiddleware)
                pubkey, exists := r.Context().Value("pubkey").(string)
                if !exists || pubkey == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Missing pubkey in context", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                auth, err := m.getNostrAuth(ctx, pubkey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to get auth: %v", err)
                        http.Error(w, "Authentication failed", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if !auth.Active </span><span class="cov0" title="0">{
                        http.Error(w, "Account inactive", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">go m.updateLastUsed(context.Background(), pubkey)

                // Add firebase_uid to context
                ctx = context.WithValue(r.Context(), "firebase_uid", auth.FirebaseUID)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

// Middleware provides the full NIP-98 authentication (signature + database lookup)
func (m *NIP98Middleware) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return m.SignatureValidationMiddleware(m.DatabaseLookupMiddleware(next))
}</span>

func (m *NIP98Middleware) getNostrAuth(ctx context.Context, pubkey string) (*models.NostrAuth, error) <span class="cov0" title="0">{
        query := m.firestoreClient.Collection("nostr_auth").Where("pubkey", "==", pubkey).Where("active", "==", true).Limit(1)
        iter := query.Documents(ctx)
        defer iter.Stop()

        doc, err := iter.Next()
        if err == iterator.Done </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pubkey not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var auth models.NostrAuth
        if err := doc.DataTo(&amp;auth); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;auth, nil</span>
}

func (m *NIP98Middleware) updateLastUsed(ctx context.Context, pubkey string) <span class="cov0" title="0">{
        query := m.firestoreClient.Collection("nostr_auth").Where("pubkey", "==", pubkey).Limit(1)
        iter := query.Documents(ctx)
        defer iter.Stop()

        doc, err := iter.Next()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, err = doc.Ref.Update(ctx, []firestore.Update{
                {Path: "last_used_at", Value: time.Now()},
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update last_used_at: %v", err)
        }</span>
}

func (m *NIP98Middleware) operator(handler http.Handler) http.Handler <span class="cov0" title="0">{
        return m.Middleware(handler)
}</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "os"
        "strconv"
        "strings"
)

// DevConfig holds development-specific configuration
type DevConfig struct {
        IsDevelopment     bool
        MockStorage       bool
        MockStoragePath   string
        FileServerURL     string
        LogRequests       bool
        LogResponses      bool
        LogHeaders        bool
        LogRequestBody    bool
        LogResponseBody   bool
        SkipAuth          bool
}

// LoadDevConfig loads development configuration from environment
func LoadDevConfig() DevConfig <span class="cov0" title="0">{
        return DevConfig{
                IsDevelopment:     getBoolEnv("DEVELOPMENT", false),
                MockStorage:       getBoolEnv("MOCK_STORAGE", false),
                MockStoragePath:   getEnv("MOCK_STORAGE_PATH", "./dev-storage"),
                FileServerURL:     getEnv("FILE_SERVER_URL", "http://localhost:8081"),
                LogRequests:       getBoolEnv("LOG_REQUESTS", true),
                LogResponses:      getBoolEnv("LOG_RESPONSES", true),
                LogHeaders:        getBoolEnv("LOG_HEADERS", true),
                LogRequestBody:    getBoolEnv("LOG_REQUEST_BODY", false),
                LogResponseBody:   getBoolEnv("LOG_RESPONSE_BODY", false),
                SkipAuth:          getBoolEnv("SKIP_AUTH", false),
        }
}</span>

// IsFirestoreEmulated checks if we're using the Firestore emulator
func IsFirestoreEmulated() bool <span class="cov0" title="0">{
        return os.Getenv("FIRESTORE_EMULATOR_HOST") != ""
}</span>

// Helper functions
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getBoolEnv(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                val, err := strconv.ParseBool(value)
                if err == nil </span><span class="cov0" title="0">{
                        return val
                }</span>
                // Also handle "yes/no", "on/off", etc.
                <span class="cov0" title="0">value = strings.ToLower(value)
                return value == "yes" || value == "on" || value == "true" || value == "1"</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getIntEnv(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import "os"

// ServiceConfig holds service-specific configuration
type ServiceConfig struct {
        // ServiceAccountEmail is used for generating presigned URLs
        ServiceAccountEmail string
}

// NewServiceConfig creates a new service configuration from environment
func NewServiceConfig() *ServiceConfig <span class="cov0" title="0">{
        serviceAccountEmail := os.Getenv("SERVICE_ACCOUNT_EMAIL")
        if serviceAccountEmail == "" </span><span class="cov0" title="0">{
                // Default for backward compatibility - should be overridden in production
                serviceAccountEmail = "api-service@wavlake-alpha.iam.gserviceaccount.com"
        }</span>
        
        <span class="cov0" title="0">return &amp;ServiceConfig{
                ServiceAccountEmail: serviceAccountEmail,
        }</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

type AuthHandlers struct {
        userService services.UserServiceInterface
}

func NewAuthHandlers(userService services.UserServiceInterface) *AuthHandlers <span class="cov8" title="1">{
        return &amp;AuthHandlers{
                userService: userService,
        }
}</span>

// LinkPubkeyRequest represents the request body for linking a pubkey
type LinkPubkeyRequest struct {
        PubKey string `json:"pubkey,omitempty"`
}

// LinkPubkeyResponse represents the response for linking a pubkey
type LinkPubkeyResponse struct {
        Success     bool   `json:"success"`
        Message     string `json:"message"`
        FirebaseUID string `json:"firebase_uid"`
        PubKey      string `json:"pubkey"`
        LinkedAt    string `json:"linked_at"`
}

// LinkPubkey handles POST /v1/auth/link-pubkey
// Requires dual authentication (Firebase + NIP-98)
func (h *AuthHandlers) LinkPubkey(c *gin.Context) <span class="cov8" title="1">{
        // Get auth info from context (set by DualAuthMiddleware)
        firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Firebase authentication"})
                return
        }</span>

        <span class="cov8" title="1">nostrPubkey, exists := c.Get("nostr_pubkey")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Nostr authentication"})
                return
        }</span>

        <span class="cov8" title="1">pubkey := nostrPubkey.(string)
        uid := firebaseUID.(string)

        log.Printf("Firebase UID: %v", firebaseUID)
        log.Printf("Nostr Pubkey: %v", nostrPubkey)
        log.Printf("Auth header: %v", c.GetHeader("Authorization"))
        log.Printf("Nostr Auth header: %v", c.GetHeader("X-Nostr-Authorization"))

        // Optional: validate request body pubkey matches auth pubkey
        var req LinkPubkeyRequest
        if err := c.ShouldBindJSON(&amp;req); err == nil &amp;&amp; req.PubKey != "" </span><span class="cov8" title="1">{
                if req.PubKey != pubkey </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Request pubkey does not match authenticated pubkey"})
                        return
                }</span>
        }

        // Link the pubkey to the Firebase user
        <span class="cov8" title="1">err := h.userService.LinkPubkeyToUser(c.Request.Context(), pubkey, uid)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := LinkPubkeyResponse{
                Success:     true,
                Message:     "Pubkey linked successfully to Firebase account",
                FirebaseUID: uid,
                PubKey:      pubkey,
                LinkedAt:    time.Now().Format(time.RFC3339),
        }

        c.JSON(http.StatusOK, response)</span>
}

// UnlinkPubkeyRequest represents the request body for unlinking a pubkey
type UnlinkPubkeyRequest struct {
        PubKey string `json:"pubkey" binding:"required"`
}

// UnlinkPubkeyResponse represents the response for unlinking a pubkey
type UnlinkPubkeyResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        PubKey  string `json:"pubkey"`
}

// UnlinkPubkey handles POST /v1/auth/unlink-pubkey
// Requires Firebase authentication only
func (h *AuthHandlers) UnlinkPubkey(c *gin.Context) <span class="cov8" title="1">{
        // Get Firebase UID from context (set by FirebaseMiddleware)
        firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Firebase authentication"})
                return
        }</span>

        <span class="cov8" title="1">var req UnlinkPubkeyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov8" title="1">uid := firebaseUID.(string)

        // Unlink the pubkey from the Firebase user
        err := h.userService.UnlinkPubkeyFromUser(c.Request.Context(), req.PubKey, uid)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">response := UnlinkPubkeyResponse{
                Success: true,
                Message: "Pubkey unlinked successfully from Firebase account",
                PubKey:  req.PubKey,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetLinkedPubkeysResponse represents the response for getting linked pubkeys
type GetLinkedPubkeysResponse struct {
        Success       bool                      `json:"success"`
        FirebaseUID   string                    `json:"firebase_uid"`
        LinkedPubkeys []models.LinkedPubkeyInfo `json:"linked_pubkeys"`
}

// GetLinkedPubkeys handles GET /v1/auth/get-linked-pubkeys
// Requires Firebase authentication only
func (h *AuthHandlers) GetLinkedPubkeys(c *gin.Context) <span class="cov8" title="1">{
        // Get Firebase UID from context (set by FirebaseMiddleware)
        firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Firebase authentication"})
                return
        }</span>

        <span class="cov8" title="1">uid := firebaseUID.(string)

        // Get linked pubkeys for the user
        pubkeys, err := h.userService.GetLinkedPubkeys(c.Request.Context(), uid)
        if err != nil </span><span class="cov8" title="1">{
                // Log the actual error for debugging
                c.Header("X-Debug-Error", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to retrieve linked pubkeys",
                        "debug": err.Error(),
                })
                return
        }</span>

        // Convert to response format
        <span class="cov8" title="1">var linkedPubkeys []models.LinkedPubkeyInfo
        for _, p := range pubkeys </span><span class="cov8" title="1">{
                info := models.LinkedPubkeyInfo{
                        PubKey:   p.Pubkey,
                        LinkedAt: p.LinkedAt.Format(time.RFC3339),
                }

                if !p.LastUsedAt.IsZero() </span><span class="cov8" title="1">{
                        info.LastUsedAt = p.LastUsedAt.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">linkedPubkeys = append(linkedPubkeys, info)</span>
        }

        // Ensure we always return an empty array instead of null
        <span class="cov8" title="1">if linkedPubkeys == nil </span><span class="cov8" title="1">{
                linkedPubkeys = []models.LinkedPubkeyInfo{}
        }</span>

        <span class="cov8" title="1">response := GetLinkedPubkeysResponse{
                Success:       true,
                FirebaseUID:   uid,
                LinkedPubkeys: linkedPubkeys,
        }

        c.JSON(http.StatusOK, response)</span>
}

// CheckPubkeyLinkRequest represents the request body for checking pubkey link status
type CheckPubkeyLinkRequest struct {
        PubKey string `json:"pubkey" binding:"required"`
}

// CheckPubkeyLinkResponse represents the response for checking pubkey link status
type CheckPubkeyLinkResponse struct {
        Success     bool   `json:"success"`
        IsLinked    bool   `json:"is_linked"`
        FirebaseUID string `json:"firebase_uid,omitempty"`
        PubKey      string `json:"pubkey"`
        Email       string `json:"email,omitempty"`
}

// CheckPubkeyLink handles POST /v1/auth/check-pubkey-link
// Requires NIP-98 authentication - users can only check their own pubkey
func (h *AuthHandlers) CheckPubkeyLink(c *gin.Context) <span class="cov8" title="1">{
        // Get authenticated pubkey from NIP-98 middleware
        authPubkey, exists := c.Get("pubkey")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing Nostr authentication"})
                return
        }</span>

        <span class="cov8" title="1">var req CheckPubkeyLinkRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body - pubkey is required"})
                return
        }</span>

        // Verify that the authenticated pubkey matches the requested pubkey
        <span class="cov8" title="1">if authPubkey.(string) != req.PubKey </span><span class="cov8" title="1">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You can only check linking status for your own pubkey"})
                return
        }</span>

        // Check if the pubkey is linked to any Firebase account
        <span class="cov8" title="1">firebaseUID, err := h.userService.GetFirebaseUIDByPubkey(c.Request.Context(), req.PubKey)
        if err != nil </span><span class="cov8" title="1">{
                // If error is "not found", it means pubkey is not linked
                response := CheckPubkeyLinkResponse{
                        Success:     true,
                        IsLinked:    false,
                        FirebaseUID: "",
                        PubKey:      req.PubKey,
                        Email:       "",
                }
                c.JSON(http.StatusOK, response)
                return
        }</span>

        // Pubkey is linked - get the user's email address
        <span class="cov8" title="1">email, err := h.userService.GetUserEmail(c.Request.Context(), firebaseUID)
        if err != nil </span><span class="cov8" title="1">{
                // Log the error but continue without email
                log.Printf("Failed to get email for Firebase UID %s: %v", firebaseUID, err)
                email = ""
        }</span>

        <span class="cov8" title="1">response := CheckPubkeyLinkResponse{
                Success:     true,
                IsLinked:    true,
                FirebaseUID: firebaseUID,
                PubKey:      req.PubKey,
                Email:       email,
        }

        c.JSON(http.StatusOK, response)</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

// AuthTokenHandler handles token-based authentication operations
type AuthTokenHandler struct {
        tokenService services.TokenServiceInterface
}

// NewAuthTokenHandler creates a new auth token handler
func NewAuthTokenHandler(tokenService services.TokenServiceInterface) *AuthTokenHandler <span class="cov8" title="1">{
        return &amp;AuthTokenHandler{
                tokenService: tokenService,
        }
}</span>

// TokenResponse represents a generic token response
type TokenResponse struct {
        Success bool                    `json:"success"`
        Data    *models.FileUploadToken `json:"data,omitempty"`
        Error   string                  `json:"error,omitempty"`
        Message string                  `json:"message,omitempty"`
}

// GenerateUploadToken handles upload token generation  
func (h *AuthTokenHandler) GenerateUploadToken(c *gin.Context) <span class="cov8" title="1">{
        type generateUploadTokenRequest struct {
                Path       string `json:"path" binding:"required"`
                Expiration int    `json:"expiration"` // Expiration in minutes
        }
        
        var req generateUploadTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, TokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Require authentication
        <span class="cov8" title="1">firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, TokenResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov8" title="1">userID := firebaseUID.(string)

        // Set default expiration
        expiration := time.Duration(req.Expiration) * time.Minute
        if expiration == 0 </span><span class="cov8" title="1">{
                expiration = 1 * time.Hour
        }</span>

        // Generate token
        <span class="cov8" title="1">token, err := h.tokenService.GenerateUploadToken(c.Request.Context(), req.Path, userID, expiration)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, TokenResponse{
                        Success: false,
                        Error:   "failed to generate upload token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, TokenResponse{
                Success: true,
                Data:    token,
        })</span>
}

// GenerateDeleteTokenRequest represents the request for delete token generation
type GenerateDeleteTokenRequest struct {
        Path       string `json:"path" binding:"required"`
        Expiration int    `json:"expiration"` // Expiration in minutes
}

// GenerateDeleteToken handles delete token generation
func (h *AuthTokenHandler) GenerateDeleteToken(c *gin.Context) <span class="cov8" title="1">{
        var req GenerateDeleteTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, TokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Require authentication
        <span class="cov8" title="1">firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, TokenResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov8" title="1">userID := firebaseUID.(string)

        // Set default expiration
        expiration := time.Duration(req.Expiration) * time.Minute
        if expiration == 0 </span><span class="cov0" title="0">{
                expiration = 1 * time.Hour
        }</span>

        // Generate delete token
        <span class="cov8" title="1">token, err := h.tokenService.GenerateDeleteToken(c.Request.Context(), req.Path, userID, expiration)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, TokenResponse{
                        Success: false,
                        Error:   "failed to generate delete token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, TokenResponse{
                Success: true,
                Data:    token,
        })</span>
}

// ValidateTokenRequest represents the request for token validation
type ValidateTokenRequest struct {
        Token string `json:"token" binding:"required"`
        Path  string `json:"path" binding:"required"`
}

// ValidateToken handles token validation
func (h *AuthTokenHandler) ValidateToken(c *gin.Context) <span class="cov8" title="1">{
        var req ValidateTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, TokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Validate token
        <span class="cov8" title="1">token, err := h.tokenService.ValidateToken(c.Request.Context(), req.Token, req.Path)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, TokenResponse{
                        Success: false,
                        Error:   "invalid or expired token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, TokenResponse{
                Success: true,
                Data:    token,
        })</span>
}

// RevokeTokenRequest represents the request for token revocation
type RevokeTokenRequest struct {
        Token string `json:"token" binding:"required"`
}

// RevokeTokenResponse represents the response for token revocation
type RevokeTokenResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
        Message string `json:"message,omitempty"`
}

// RevokeToken handles token revocation
func (h *AuthTokenHandler) RevokeToken(c *gin.Context) <span class="cov8" title="1">{
        var req RevokeTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, RevokeTokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Revoke token
        <span class="cov8" title="1">err := h.tokenService.RevokeToken(c.Request.Context(), req.Token)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, RevokeTokenResponse{
                        Success: false,
                        Error:   "failed to revoke token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, RevokeTokenResponse{
                Success: true,
                Message: "token revoked successfully",
        })</span>
}

// ListActiveTokensResponse represents the response for active token listing
type ListActiveTokensResponse struct {
        Success bool                      `json:"success"`
        Data    []models.FileUploadToken  `json:"data,omitempty"`
        Error   string                    `json:"error,omitempty"`
}

// ListActiveTokens handles active token listing
func (h *AuthTokenHandler) ListActiveTokens(c *gin.Context) <span class="cov8" title="1">{
        // Require authentication
        firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, ListActiveTokensResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov8" title="1">userID := firebaseUID.(string)

        // Get active tokens
        tokens, err := h.tokenService.ListActiveTokens(c.Request.Context(), userID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, ListActiveTokensResponse{
                        Success: false,
                        Error:   "failed to list active tokens",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, ListActiveTokensResponse{
                Success: true,
                Data:    tokens,
        })</span>
}

// RefreshTokenRequest represents the request for token refresh
type RefreshTokenRequest struct {
        Token      string `json:"token" binding:"required"`
        Expiration int    `json:"expiration"` // New expiration in minutes
}

// RefreshToken handles token refresh
func (h *AuthTokenHandler) RefreshToken(c *gin.Context) <span class="cov8" title="1">{
        var req RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, TokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Set default expiration
        <span class="cov8" title="1">expiration := time.Duration(req.Expiration) * time.Minute
        if expiration == 0 </span><span class="cov8" title="1">{
                expiration = 1 * time.Hour
        }</span>

        // Refresh token
        <span class="cov8" title="1">refreshedToken, err := h.tokenService.RefreshToken(c.Request.Context(), req.Token, expiration)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, TokenResponse{
                        Success: false,
                        Error:   "failed to refresh token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, TokenResponse{
                Success: true,
                Data:    refreshedToken,
        })</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/services"
)

// DevelopmentHandler handles development utilities and debugging
type DevelopmentHandler struct {
        developmentService services.DevelopmentServiceInterface
}

// NewDevelopmentHandler creates a new development handler
func NewDevelopmentHandler(developmentService services.DevelopmentServiceInterface) *DevelopmentHandler <span class="cov8" title="1">{
        return &amp;DevelopmentHandler{
                developmentService: developmentService,
        }
}</span>

// DevResponse represents a generic development response
type DevResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// ResetDatabase handles database reset operations
func (h *DevelopmentHandler) ResetDatabase(c *gin.Context) <span class="cov8" title="1">{
        // Only allow in development environment
        if gin.Mode() == gin.ReleaseMode </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, DevResponse{
                        Success: false,
                        Error:   "not available in production",
                })
                return
        }</span>

        <span class="cov8" title="1">err := h.developmentService.ResetDatabase(c.Request.Context())
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to reset database",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Message: "database reset successfully",
        })</span>
}

// SeedTestData handles test data seeding operations
func (h *DevelopmentHandler) SeedTestData(c *gin.Context) <span class="cov8" title="1">{
        // Only allow in development environment
        if gin.Mode() == gin.ReleaseMode </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, DevResponse{
                        Success: false,
                        Error:   "not available in production",
                })
                return
        }</span>

        <span class="cov8" title="1">err := h.developmentService.SeedTestData(c.Request.Context())
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to seed test data",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Message: "test data seeded successfully",
        })</span>
}

// GetSystemInfo handles system information retrieval
func (h *DevelopmentHandler) GetSystemInfo(c *gin.Context) <span class="cov0" title="0">{
        info, err := h.developmentService.GetSystemInfo(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to get system info",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Data:    info,
        })</span>
}

// ClearCache handles cache clearing operations
func (h *DevelopmentHandler) ClearCache(c *gin.Context) <span class="cov0" title="0">{
        err := h.developmentService.ClearCache(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to clear cache",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Message: "cache cleared successfully",
        })</span>
}

// GenerateTestFilesRequest represents the request for test file generation
type GenerateTestFilesRequest struct {
        Count int `json:"count"`
}

// GenerateTestFiles handles test file generation
func (h *DevelopmentHandler) GenerateTestFiles(c *gin.Context) <span class="cov0" title="0">{
        // Only allow in development environment
        if gin.Mode() == gin.ReleaseMode </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, DevResponse{
                        Success: false,
                        Error:   "not available in production",
                })
                return
        }</span>

        <span class="cov0" title="0">count := 10 // default
        if countStr := c.Query("count"); countStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(countStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        count = parsed
                }</span>
        }

        <span class="cov0" title="0">files, err := h.developmentService.GenerateTestFiles(c.Request.Context(), count)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to generate test files",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Data:    files,
                Message: "test files generated successfully",
        })</span>
}

// SimulateLoadRequest represents the request for load simulation
type SimulateLoadRequest struct {
        Duration int `json:"duration"` // duration in seconds
}

// SimulateLoad handles load simulation for testing
func (h *DevelopmentHandler) SimulateLoad(c *gin.Context) <span class="cov0" title="0">{
        // Only allow in development environment
        if gin.Mode() == gin.ReleaseMode </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, DevResponse{
                        Success: false,
                        Error:   "not available in production",
                })
                return
        }</span>

        <span class="cov0" title="0">duration := 30 * time.Second // default
        if durationStr := c.Query("duration"); durationStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(durationStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        duration = time.Duration(parsed) * time.Second
                }</span>
        }

        <span class="cov0" title="0">err := h.developmentService.SimulateLoad(c.Request.Context(), duration)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to simulate load",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Message: "load simulation completed",
        })</span>
}

// GetLogs handles log retrieval for debugging
func (h *DevelopmentHandler) GetLogs(c *gin.Context) <span class="cov0" title="0">{
        level := c.Query("level")
        if level == "" </span><span class="cov0" title="0">{
                level = "info"
        }</span>

        <span class="cov0" title="0">limit := 100 // default
        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov0" title="0">logs, err := h.developmentService.GetLogs(c.Request.Context(), level, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DevResponse{
                        Success: false,
                        Error:   "failed to get logs",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DevResponse{
                Success: true,
                Data:    logs,
        })</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

// FileServerHandler handles file server operations
type FileServerHandler struct {
        fileServerService services.FileServerServiceInterface
        tokenService      services.TokenServiceInterface
}

// NewFileServerHandler creates a new file server handler
func NewFileServerHandler(fileServerService services.FileServerServiceInterface, tokenService services.TokenServiceInterface) *FileServerHandler <span class="cov0" title="0">{
        return &amp;FileServerHandler{
                fileServerService: fileServerService,
                tokenService:      tokenService,
        }
}</span>

// UploadFileRequest represents the request for file upload
type UploadFileRequest struct {
        Path        string `form:"path" binding:"required"`
        ContentType string `form:"content_type"`
}

// UploadFileResponse represents the response for file upload
type UploadFileResponse struct {
        Success bool                 `json:"success"`
        Data    *models.FileMetadata `json:"data,omitempty"`
        Error   string               `json:"error,omitempty"`
}

// UploadFile handles file upload operations (POST/PUT)
func (h *FileServerHandler) UploadFile(c *gin.Context) <span class="cov0" title="0">{
        // Parse form data
        var req UploadFileRequest
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, UploadFileResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Validate token if provided
        <span class="cov0" title="0">token := c.Query("token")
        if token != "" </span><span class="cov0" title="0">{
                _, err := h.tokenService.ValidateToken(c.Request.Context(), token, req.Path)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, UploadFileResponse{
                                Success: false,
                                Error:   "invalid or expired token",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Require authentication if no token
                firebaseUID, exists := c.Get("firebase_uid")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, UploadFileResponse{
                                Success: false,
                                Error:   "authentication required",
                        })
                        return
                }</span>
                <span class="cov0" title="0">_ = firebaseUID</span> // Validate user has access
        }

        // Get uploaded file
        <span class="cov0" title="0">file, _, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, UploadFileResponse{
                        Success: false,
                        Error:   "no file uploaded",
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Determine content type
        contentType := req.ContentType
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        // Upload file
        <span class="cov0" title="0">metadata, err := h.fileServerService.UploadFile(c.Request.Context(), req.Path, file, contentType)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, UploadFileResponse{
                        Success: false,
                        Error:   "failed to upload file",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, UploadFileResponse{
                Success: true,
                Data:    metadata,
        })</span>
}

// DownloadFileResponse represents the response for file download
type DownloadFileResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

// DownloadFile handles file download operations
func (h *FileServerHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, DownloadFileResponse{
                        Success: false,
                        Error:   "file path is required",
                })
                return
        }</span>

        // Get file
        <span class="cov0" title="0">reader, err := h.fileServerService.DownloadFile(c.Request.Context(), path)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, DownloadFileResponse{
                        Success: false,
                        Error:   "file not found",
                })
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Get file metadata for content type
        metadata, err := h.fileServerService.GetFileMetadata(c.Request.Context(), path)
        if err == nil </span><span class="cov0" title="0">{
                c.Header("Content-Type", metadata.ContentType)
                c.Header("Content-Length", string(rune(metadata.Size)))
        }</span>

        // Stream file to response
        <span class="cov0" title="0">_, err = io.Copy(c.Writer, reader)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DownloadFileResponse{
                        Success: false,
                        Error:   "failed to stream file",
                })
                return
        }</span>
}

// DeleteFileResponse represents the response for file deletion
type DeleteFileResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
        Message string `json:"message,omitempty"`
}

// DeleteFile handles file deletion operations
func (h *FileServerHandler) DeleteFile(c *gin.Context) <span class="cov0" title="0">{
        path := c.Param("path")
        if path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, DeleteFileResponse{
                        Success: false,
                        Error:   "file path is required",
                })
                return
        }</span>

        // Validate token if provided
        <span class="cov0" title="0">token := c.Query("token")
        if token != "" </span><span class="cov0" title="0">{
                _, err := h.tokenService.ValidateToken(c.Request.Context(), token, path)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, DeleteFileResponse{
                                Success: false,
                                Error:   "invalid or expired token",
                        })
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Require authentication if no token
                firebaseUID, exists := c.Get("firebase_uid")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, DeleteFileResponse{
                                Success: false,
                                Error:   "authentication required",
                        })
                        return
                }</span>
                <span class="cov0" title="0">_ = firebaseUID</span> // Validate user has access
        }

        // Delete file
        <span class="cov0" title="0">err := h.fileServerService.DeleteFile(c.Request.Context(), path)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, DeleteFileResponse{
                        Success: false,
                        Error:   "failed to delete file",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, DeleteFileResponse{
                Success: true,
                Message: "file deleted successfully",
        })</span>
}

// GetStatusResponse represents the response for status check
type GetStatusResponse struct {
        Success bool              `json:"success"`
        Data    map[string]string `json:"data,omitempty"`
        Error   string            `json:"error,omitempty"`
}

// GetStatus handles health check operations
func (h *FileServerHandler) GetStatus(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, GetStatusResponse{
                Success: true,
                Data: map[string]string{
                        "status":    "healthy",
                        "service":   "file-server",
                        "timestamp": time.Now().Format(time.RFC3339),
                },
        })
}</span>

// ListFilesResponse represents the response for file listing
type ListFilesResponse struct {
        Success bool     `json:"success"`
        Data    []string `json:"data,omitempty"`
        Error   string   `json:"error,omitempty"`
}

// ListFiles handles file listing operations
func (h *FileServerHandler) ListFiles(c *gin.Context) <span class="cov0" title="0">{
        prefix := c.Query("prefix")

        // Require authentication
        firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, ListFilesResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>
        <span class="cov0" title="0">_ = firebaseUID // Validate user has access

        // List files
        files, err := h.fileServerService.ListFiles(c.Request.Context(), prefix)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, ListFilesResponse{
                        Success: false,
                        Error:   "failed to list files",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, ListFilesResponse{
                Success: true,
                Data:    files,
        })</span>
}

// GenerateUploadTokenRequest represents the request for generating upload token
type GenerateUploadTokenRequest struct {
        Path       string `json:"path" binding:"required"`
        Expiration int    `json:"expiration"` // Expiration in minutes
}

// GenerateUploadTokenResponse represents the response for upload token generation
type GenerateUploadTokenResponse struct {
        Success bool                     `json:"success"`
        Data    *models.FileUploadToken  `json:"data,omitempty"`
        Error   string                   `json:"error,omitempty"`
}

// GenerateUploadToken handles upload token generation
func (h *FileServerHandler) GenerateUploadToken(c *gin.Context) <span class="cov0" title="0">{
        var req GenerateUploadTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, GenerateUploadTokenResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Require authentication
        <span class="cov0" title="0">firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, GenerateUploadTokenResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">userID := firebaseUID.(string)

        // Set default expiration
        expiration := time.Duration(req.Expiration) * time.Minute
        if expiration == 0 </span><span class="cov0" title="0">{
                expiration = 1 * time.Hour
        }</span>

        // Generate token
        <span class="cov0" title="0">token, err := h.fileServerService.GenerateUploadToken(c.Request.Context(), req.Path, userID, expiration)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, GenerateUploadTokenResponse{
                        Success: false,
                        Error:   "failed to generate token",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, GenerateUploadTokenResponse{
                Success: true,
                Data:    token,
        })</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
)

type HeartbeatResponse struct {
        Status string `json:"status"`
}

func Heartbeat(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">response := HeartbeatResponse{
                Status: "ok",
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                // Log error but response headers are already sent
                // In production, this would be logged to your logging system
                _ = err
        }</span>
}

func NotFound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        http.Error(w, "Not found", http.StatusNotFound)
}</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "database/sql"
        "log"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

type LegacyHandler struct {
        postgresService services.PostgresServiceInterface
}

// NewLegacyHandler creates a new legacy handler
func NewLegacyHandler(postgresService services.PostgresServiceInterface) *LegacyHandler <span class="cov8" title="1">{
        return &amp;LegacyHandler{
                postgresService: postgresService,
        }
}</span>

// isDatabaseError checks if the error is a database/SQL error vs user-not-found
func isDatabaseError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // If it's sql.ErrNoRows, it's a legitimate "not found" case
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()
        // Check for common database/SQL errors
        databaseErrors := []string{
                "relation", "does not exist",
                "syntax error", "column", "unknown",
                "connection", "timeout", "network",
                "permission denied", "access denied",
                "invalid", "constraint",
        }

        for _, dbErr := range databaseErrors </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(errMsg), dbErr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// UserMetadataResponse represents the complete user metadata response
type UserMetadataResponse struct {
        User    *models.LegacyUser    `json:"user"`
        Artists []models.LegacyArtist `json:"artists"`
        Albums  []models.LegacyAlbum  `json:"albums"`
        Tracks  []models.LegacyTrack  `json:"tracks"`
}

// GetUserMetadata handles GET /v1/legacy/metadata
// Returns all user metadata from the legacy PostgreSQL system
func (h *LegacyHandler) GetUserMetadata(c *gin.Context) <span class="cov8" title="1">{
        firebaseUID := c.GetString("firebase_uid")

        if firebaseUID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Failed to find an associated Firebase UID"})
                return
        }</span>

        <span class="cov8" title="1">ctx := c.Request.Context()

        // Get user data
        user, err := h.postgresService.GetUserByFirebaseUID(ctx, firebaseUID)
        if err != nil </span><span class="cov8" title="1">{
                // Check if this is a database error vs user not found
                if isDatabaseError(err) </span><span class="cov8" title="1">{
                        log.Printf("PostgreSQL error getting user %s: %v", firebaseUID, err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                        return
                }</span>
                // User not found is normal - return empty response
                <span class="cov8" title="1">user = nil</span>
        }

        // Get all related data (empty arrays if user doesn't exist)
        <span class="cov8" title="1">var artists []models.LegacyArtist
        var albums []models.LegacyAlbum
        var tracks []models.LegacyTrack

        if user != nil </span><span class="cov8" title="1">{
                // Get artists
                if artistsResult, err := h.postgresService.GetUserArtists(ctx, firebaseUID); err == nil </span><span class="cov8" title="1">{
                        artists = artistsResult
                }</span> else<span class="cov8" title="1"> if isDatabaseError(err) </span><span class="cov8" title="1">{
                        log.Printf("PostgreSQL error getting artists for %s: %v", firebaseUID, err)
                }</span>

                // Get albums
                <span class="cov8" title="1">if albumsResult, err := h.postgresService.GetUserAlbums(ctx, firebaseUID); err == nil </span><span class="cov8" title="1">{
                        albums = albumsResult
                }</span> else<span class="cov8" title="1"> if isDatabaseError(err) </span><span class="cov8" title="1">{
                        log.Printf("PostgreSQL error getting albums for %s: %v", firebaseUID, err)
                }</span>

                // Get tracks
                <span class="cov8" title="1">if tracksResult, err := h.postgresService.GetUserTracks(ctx, firebaseUID); err == nil </span><span class="cov8" title="1">{
                        tracks = tracksResult
                }</span> else<span class="cov8" title="1"> if isDatabaseError(err) </span><span class="cov8" title="1">{
                        log.Printf("PostgreSQL error getting tracks for %s: %v", firebaseUID, err)
                }</span>
        }

        // Ensure we always return empty arrays instead of null
        <span class="cov8" title="1">if artists == nil </span><span class="cov8" title="1">{
                artists = []models.LegacyArtist{}
        }</span>
        <span class="cov8" title="1">if albums == nil </span><span class="cov8" title="1">{
                albums = []models.LegacyAlbum{}
        }</span>
        <span class="cov8" title="1">if tracks == nil </span><span class="cov8" title="1">{
                tracks = []models.LegacyTrack{}
        }</span>

        <span class="cov8" title="1">response := UserMetadataResponse{
                User:    user,
                Artists: artists,
                Albums:  albums,
                Tracks:  tracks,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetUserTracks handles GET /v1/legacy/tracks
func (h *LegacyHandler) GetUserTracks(c *gin.Context) <span class="cov8" title="1">{
        firebaseUID := c.GetString("firebase_uid")
        if firebaseUID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                return
        }</span>

        <span class="cov8" title="1">tracks, err := h.postgresService.GetUserTracks(c.Request.Context(), firebaseUID)
        if err != nil &amp;&amp; isDatabaseError(err) </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
                return
        }</span>

        <span class="cov8" title="1">if tracks == nil </span><span class="cov8" title="1">{
                tracks = []models.LegacyTrack{}
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"tracks": tracks})</span>
}

// GetUserArtists handles GET /v1/legacy/artists
func (h *LegacyHandler) GetUserArtists(c *gin.Context) <span class="cov8" title="1">{
        firebaseUID := c.GetString("firebase_uid")
        if firebaseUID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                return
        }</span>

        <span class="cov8" title="1">artists, err := h.postgresService.GetUserArtists(c.Request.Context(), firebaseUID)
        if err != nil &amp;&amp; isDatabaseError(err) </span><span class="cov8" title="1">{
                log.Printf("PostgreSQL error getting artists for %s: %v", firebaseUID, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
                return
        }</span>

        <span class="cov8" title="1">if artists == nil </span><span class="cov8" title="1">{
                artists = []models.LegacyArtist{}
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"artists": artists})</span>
}

// GetUserAlbums handles GET /v1/legacy/albums
func (h *LegacyHandler) GetUserAlbums(c *gin.Context) <span class="cov8" title="1">{
        firebaseUID := c.GetString("firebase_uid")
        if firebaseUID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                return
        }</span>

        <span class="cov8" title="1">albums, err := h.postgresService.GetUserAlbums(c.Request.Context(), firebaseUID)
        if err != nil &amp;&amp; isDatabaseError(err) </span><span class="cov8" title="1">{
                log.Printf("PostgreSQL error getting albums for %s: %v", firebaseUID, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
                return
        }</span>

        <span class="cov8" title="1">if albums == nil </span><span class="cov8" title="1">{
                albums = []models.LegacyAlbum{}
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"albums": albums})</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

// MockStorageHandler handles mock storage operations for development
type MockStorageHandler struct {
        mockStorageService services.MockStorageServiceInterface
}

// NewMockStorageHandler creates a new mock storage handler
func NewMockStorageHandler(mockStorageService services.MockStorageServiceInterface) *MockStorageHandler <span class="cov0" title="0">{
        return &amp;MockStorageHandler{
                mockStorageService: mockStorageService,
        }
}</span>

// UploadFileRequest represents the request for mock storage file upload
type MockUploadFileRequest struct {
        Bucket      string `form:"bucket" binding:"required"`
        Path        string `form:"path" binding:"required"`
        ContentType string `form:"content_type"`
}

// UploadFileResponse represents the response for mock storage operations
type MockStorageResponse struct {
        Success bool                 `json:"success"`
        Data    *models.FileMetadata `json:"data,omitempty"`
        Error   string               `json:"error,omitempty"`
}

// UploadFile handles mock storage file upload
func (h *MockStorageHandler) UploadFile(c *gin.Context) <span class="cov0" title="0">{
        var req MockUploadFileRequest
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, MockStorageResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Get uploaded file
        <span class="cov0" title="0">file, _, err := c.Request.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, MockStorageResponse{
                        Success: false,
                        Error:   "no file uploaded",
                })
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Determine content type
        contentType := req.ContentType
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        // Upload to mock storage
        <span class="cov0" title="0">metadata, err := h.mockStorageService.UploadFile(c.Request.Context(), req.Bucket, req.Path, file, contentType)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, MockStorageResponse{
                        Success: false,
                        Error:   "failed to upload file",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MockStorageResponse{
                Success: true,
                Data:    metadata,
        })</span>
}

// DownloadFile handles mock storage file download
func (h *MockStorageHandler) DownloadFile(c *gin.Context) <span class="cov0" title="0">{
        bucket := c.Param("bucket")
        path := c.Param("path")

        if bucket == "" || path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, MockStorageResponse{
                        Success: false,
                        Error:   "bucket and path are required",
                })
                return
        }</span>

        // Get file from mock storage
        <span class="cov0" title="0">reader, err := h.mockStorageService.DownloadFile(c.Request.Context(), bucket, path)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, MockStorageResponse{
                        Success: false,
                        Error:   "file not found",
                })
                return
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Stream file to response
        c.DataFromReader(http.StatusOK, -1, "application/octet-stream", reader, nil)</span>
}

// DeleteFile handles mock storage file deletion
type MockDeleteResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
        Message string `json:"message,omitempty"`
}

// DeleteFile handles mock storage file deletion
func (h *MockStorageHandler) DeleteFile(c *gin.Context) <span class="cov0" title="0">{
        bucket := c.Param("bucket")
        path := c.Param("path")

        if bucket == "" || path == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, MockDeleteResponse{
                        Success: false,
                        Error:   "bucket and path are required",
                })
                return
        }</span>

        // Delete from mock storage
        <span class="cov0" title="0">err := h.mockStorageService.DeleteFile(c.Request.Context(), bucket, path)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, MockDeleteResponse{
                        Success: false,
                        Error:   "failed to delete file",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MockDeleteResponse{
                Success: true,
                Message: "file deleted successfully",
        })</span>
}

// ListFilesResponse represents the response for mock storage file listing
type MockListFilesResponse struct {
        Success bool     `json:"success"`
        Data    []string `json:"data,omitempty"`
        Error   string   `json:"error,omitempty"`
}

// ListFiles handles mock storage file listing
func (h *MockStorageHandler) ListFiles(c *gin.Context) <span class="cov0" title="0">{
        bucket := c.Query("bucket")
        prefix := c.Query("prefix")

        if bucket == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, MockListFilesResponse{
                        Success: false,
                        Error:   "bucket parameter is required",
                })
                return
        }</span>

        // List files from mock storage
        <span class="cov0" title="0">files, err := h.mockStorageService.ListFiles(c.Request.Context(), bucket, prefix)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, MockListFilesResponse{
                        Success: false,
                        Error:   "failed to list files",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MockListFilesResponse{
                Success: true,
                Data:    files,
        })</span>
}

// GetBucketInfoResponse represents the response for bucket information
type GetBucketInfoResponse struct {
        Success bool                `json:"success"`
        Data    *models.BucketInfo  `json:"data,omitempty"`
        Error   string              `json:"error,omitempty"`
}

// GetBucketInfo handles mock storage bucket information retrieval
func (h *MockStorageHandler) GetBucketInfo(c *gin.Context) <span class="cov0" title="0">{
        bucket := c.Param("bucket")
        if bucket == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, GetBucketInfoResponse{
                        Success: false,
                        Error:   "bucket parameter is required",
                })
                return
        }</span>

        // Get bucket info from mock storage
        <span class="cov0" title="0">info, err := h.mockStorageService.GetBucketInfo(c.Request.Context(), bucket)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, GetBucketInfoResponse{
                        Success: false,
                        Error:   "bucket not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, GetBucketInfoResponse{
                Success: true,
                Data:    info,
        })</span>
}

// CreateBucketRequest represents the request for bucket creation
type CreateBucketRequest struct {
        Bucket   string `json:"bucket" binding:"required"`
        Location string `json:"location"`
}

// CreateBucketResponse represents the response for bucket creation
type CreateBucketResponse struct {
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
        Message string `json:"message,omitempty"`
}

// CreateBucket handles mock storage bucket creation
func (h *MockStorageHandler) CreateBucket(c *gin.Context) <span class="cov0" title="0">{
        var req CreateBucketRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, CreateBucketResponse{
                        Success: false,
                        Error:   "invalid request parameters",
                })
                return
        }</span>

        // Set default location
        <span class="cov0" title="0">location := req.Location
        if location == "" </span><span class="cov0" title="0">{
                location = "us-central1"
        }</span>

        // Create bucket in mock storage
        <span class="cov0" title="0">err := h.mockStorageService.CreateBucket(c.Request.Context(), req.Bucket, location)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, CreateBucketResponse{
                        Success: false,
                        Error:   "failed to create bucket",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, CreateBucketResponse{
                Success: true,
                Message: "bucket created successfully",
        })</span>
}

// HealthCheckResponse represents the response for health check
type MockHealthCheckResponse struct {
        Success bool   `json:"success"`
        Status  string `json:"status,omitempty"`
        Error   string `json:"error,omitempty"`
}

// HealthCheck handles mock storage health check
func (h *MockStorageHandler) HealthCheck(c *gin.Context) <span class="cov0" title="0">{
        err := h.mockStorageService.HealthCheck(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, MockHealthCheckResponse{
                        Success: false,
                        Error:   "mock storage service unavailable",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, MockHealthCheckResponse{
                Success: true,
                Status:  "healthy",
        })</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "log"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

type TracksHandler struct {
        nostrTrackService services.NostrTrackServiceInterface
        processingService services.ProcessingServiceInterface
        audioProcessor    services.AudioProcessorInterface
}

func NewTracksHandler(nostrTrackService services.NostrTrackServiceInterface, processingService services.ProcessingServiceInterface, audioProcessor services.AudioProcessorInterface) *TracksHandler <span class="cov8" title="1">{
        return &amp;TracksHandler{
                nostrTrackService: nostrTrackService,
                processingService: processingService,
                audioProcessor:    audioProcessor,
        }
}</span>

type CreateNostrTrackRequest struct {
        Extension string `json:"extension" binding:"required"`
}

type CreateTrackResponse struct {
        Success bool               `json:"success"`
        Data    *models.NostrTrack `json:"data,omitempty"`
        Error   string             `json:"error,omitempty"`
        Message string             `json:"message,omitempty"`
}

// CreateTrackNostr creates a new track via NIP-98 authentication
func (h *TracksHandler) CreateTrackNostr(c *gin.Context) <span class="cov8" title="1">{
        var req CreateNostrTrackRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, CreateTrackResponse{
                        Success: false,
                        Error:   "extension field is required",
                })
                return
        }</span>

        // Validate file extension
        <span class="cov8" title="1">if !h.audioProcessor.IsFormatSupported(req.Extension) </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, CreateTrackResponse{
                        Success: false,
                        Error:   "unsupported audio format",
                })
                return
        }</span>

        // Get authenticated user info from NIP-98 middleware context
        <span class="cov8" title="1">pubkey, exists := c.Get("pubkey")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, CreateTrackResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov8" title="1">firebaseUID, exists := c.Get("firebase_uid")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, CreateTrackResponse{
                        Success: false,
                        Error:   "user account not found",
                })
                return
        }</span>

        <span class="cov8" title="1">pubkeyStr, ok := pubkey.(string)
        if !ok </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, CreateTrackResponse{
                        Success: false,
                        Error:   "invalid pubkey format",
                })
                return
        }</span>

        <span class="cov8" title="1">firebaseUIDStr, ok := firebaseUID.(string)
        if !ok </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, CreateTrackResponse{
                        Success: false,
                        Error:   "invalid user ID format",
                })
                return
        }</span>

        // Create the track
        <span class="cov8" title="1">track, err := h.nostrTrackService.CreateTrack(
                c.Request.Context(),
                pubkeyStr,
                firebaseUIDStr,
                strings.TrimPrefix(req.Extension, "."),
        )
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to create track: %v", err)
                c.JSON(http.StatusInternalServerError, CreateTrackResponse{
                        Success: false,
                        Error:   "failed to create track",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, CreateTrackResponse{
                Success: true,
                Data:    track,
        })</span>
}

type GetTracksResponse struct {
        Success bool                 `json:"success"`
        Data    []*models.NostrTrack `json:"data,omitempty"`
        Error   string               `json:"error,omitempty"`
}

// GetMyTracks returns tracks for the authenticated user
func (h *TracksHandler) GetMyTracks(c *gin.Context) <span class="cov8" title="1">{
        // Get authenticated user info from NIP-98 middleware context
        pubkey, exists := c.Get("pubkey")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, GetTracksResponse{
                        Success: false,
                        Error:   "authentication required",
                })
                return
        }</span>

        <span class="cov8" title="1">pubkeyStr, ok := pubkey.(string)
        if !ok </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, GetTracksResponse{
                        Success: false,
                        Error:   "invalid pubkey format",
                })
                return
        }</span>

        // Get tracks for this pubkey
        <span class="cov8" title="1">tracks, err := h.nostrTrackService.GetTracksByPubkey(c.Request.Context(), pubkeyStr)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Failed to get tracks for pubkey %s: %v", pubkeyStr, err)
                c.JSON(http.StatusInternalServerError, GetTracksResponse{
                        Success: false,
                        Error:   "failed to retrieve tracks",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, GetTracksResponse{
                Success: true,
                Data:    tracks,
        })</span>
}

// GetTrack returns a specific track by ID
func (h *TracksHandler) GetTrack(c *gin.Context) <span class="cov8" title="1">{
        trackID := c.Param("trackId")
        if trackID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "track ID is required"})
                return
        }</span>

        <span class="cov8" title="1">track, err := h.nostrTrackService.GetTrack(c.Request.Context(), trackID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "track not found"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "data": track})</span>
}

// DeleteTrack soft deletes a track
func (h *TracksHandler) DeleteTrack(c *gin.Context) <span class="cov8" title="1">{
        trackID := c.Param("trackId")
        if trackID == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "track ID is required"})
                return
        }</span>

        // Get authenticated user info
        <span class="cov8" title="1">pubkey, exists := c.Get("pubkey")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "authentication required"})
                return
        }</span>

        // Get track to verify ownership
        <span class="cov8" title="1">track, err := h.nostrTrackService.GetTrack(c.Request.Context(), trackID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "track not found"})
                return
        }</span>

        // Verify the user owns this track
        <span class="cov8" title="1">if track.Pubkey != pubkey.(string) </span><span class="cov8" title="1">{
                c.JSON(http.StatusForbidden, gin.H{"error": "you can only delete your own tracks"})
                return
        }</span>

        // Delete the track
        <span class="cov8" title="1">err = h.nostrTrackService.DeleteTrack(c.Request.Context(), trackID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete track"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "message": "track deleted successfully"})</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/services"
)

// WebhookHandler handles webhook operations from Cloud Functions
type WebhookHandler struct {
        webhookService services.WebhookServiceInterface
}

// NewWebhookHandler creates a new webhook handler
func NewWebhookHandler(webhookService services.WebhookServiceInterface) *WebhookHandler <span class="cov0" title="0">{
        return &amp;WebhookHandler{
                webhookService: webhookService,
        }
}</span>

// WebhookResponse represents a generic webhook response
type WebhookResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// CloudFunctionWebhook handles webhooks from Cloud Functions
func (h *WebhookHandler) CloudFunctionWebhook(c *gin.Context) <span class="cov0" title="0">{
        // Read the request body
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "failed to read request body",
                })
                return
        }</span>

        // Validate HMAC signature if present
        <span class="cov0" title="0">signature := c.GetHeader("X-Webhook-Signature")
        if signature != "" </span><span class="cov0" title="0">{
                secret := c.GetHeader("X-Webhook-Secret")
                if err := h.validateSignature(body, signature, secret); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, WebhookResponse{
                                Success: false,
                                Error:   "invalid webhook signature",
                        })
                        return
                }</span>
        }

        // Parse the webhook payload
        <span class="cov0" title="0">var payload models.WebhookPayload
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "invalid webhook payload",
                })
                return
        }</span>

        // Process the webhook
        <span class="cov0" title="0">err = h.webhookService.ProcessCloudFunctionWebhook(c.Request.Context(), payload)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, WebhookResponse{
                        Success: false,
                        Error:   "failed to process webhook",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, WebhookResponse{
                Success: true,
                Message: "webhook processed successfully",
        })</span>
}

// StorageWebhook handles webhooks from storage events
func (h *WebhookHandler) StorageWebhook(c *gin.Context) <span class="cov0" title="0">{
        // Read the request body
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "failed to read request body",
                })
                return
        }</span>

        // Validate HMAC signature if present
        <span class="cov0" title="0">signature := c.GetHeader("X-Webhook-Signature")
        if signature != "" </span><span class="cov0" title="0">{
                secret := c.GetHeader("X-Webhook-Secret")
                if err := h.validateSignature(body, signature, secret); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, WebhookResponse{
                                Success: false,
                                Error:   "invalid webhook signature",
                        })
                        return
                }</span>
        }

        // Parse the webhook payload
        <span class="cov0" title="0">var payload models.WebhookPayload
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "invalid webhook payload",
                })
                return
        }</span>

        // Process the storage webhook
        <span class="cov0" title="0">err = h.webhookService.ProcessStorageWebhook(c.Request.Context(), payload)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, WebhookResponse{
                        Success: false,
                        Error:   "failed to process storage webhook",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, WebhookResponse{
                Success: true,
                Message: "storage webhook processed successfully",
        })</span>
}

// NostrRelayWebhook handles webhooks from Nostr relay events
func (h *WebhookHandler) NostrRelayWebhook(c *gin.Context) <span class="cov0" title="0">{
        // Read the request body
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "failed to read request body",
                })
                return
        }</span>

        // Validate HMAC signature if present
        <span class="cov0" title="0">signature := c.GetHeader("X-Webhook-Signature")
        if signature != "" </span><span class="cov0" title="0">{
                secret := c.GetHeader("X-Webhook-Secret")
                if err := h.validateSignature(body, signature, secret); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, WebhookResponse{
                                Success: false,
                                Error:   "invalid webhook signature",
                        })
                        return
                }</span>
        }

        // Parse the webhook payload
        <span class="cov0" title="0">var payload models.WebhookPayload
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "invalid webhook payload",
                })
                return
        }</span>

        // Process the Nostr relay webhook
        <span class="cov0" title="0">err = h.webhookService.ProcessNostrRelayWebhook(c.Request.Context(), payload)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, WebhookResponse{
                        Success: false,
                        Error:   "failed to process Nostr relay webhook",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, WebhookResponse{
                Success: true,
                Message: "Nostr relay webhook processed successfully",
        })</span>
}

// WebhookStatus handles webhook status queries
func (h *WebhookHandler) WebhookStatus(c *gin.Context) <span class="cov0" title="0">{
        webhookID := c.Param("id")
        if webhookID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, WebhookResponse{
                        Success: false,
                        Error:   "webhook ID is required",
                })
                return
        }</span>

        // Get webhook status
        <span class="cov0" title="0">status, err := h.webhookService.GetWebhookStatus(c.Request.Context(), webhookID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, WebhookResponse{
                        Success: false,
                        Error:   "webhook status not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, WebhookResponse{
                Success: true,
                Data:    status,
        })</span>
}

// RetryFailedWebhooks handles retry of failed webhooks
func (h *WebhookHandler) RetryFailedWebhooks(c *gin.Context) <span class="cov0" title="0">{
        maxRetries := 3 // default
        if maxRetriesStr := c.Query("max_retries"); maxRetriesStr != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(maxRetriesStr); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        maxRetries = parsed
                }</span>
        }

        // Retry failed webhooks
        <span class="cov0" title="0">err := h.webhookService.RetryFailedWebhooks(c.Request.Context(), maxRetries)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, WebhookResponse{
                        Success: false,
                        Error:   "failed to retry webhooks",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, WebhookResponse{
                Success: true,
                Message: "failed webhooks retry initiated",
        })</span>
}

// validateSignature validates HMAC signature for webhook security
func (h *WebhookHandler) validateSignature(payload []byte, signature, secret string) error <span class="cov0" title="0">{
        if secret == "" </span><span class="cov0" title="0">{
                return nil // Skip validation if no secret configured
        }</span>

        // Calculate expected signature
        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        expectedSignature := hex.EncodeToString(mac.Sum(nil))

        // Compare signatures
        if !hmac.Equal([]byte(signature), []byte(expectedSignature)) </span><span class="cov0" title="0">{
                return ErrInvalidSignature
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "bytes"
        "io"
        "log/slog"
        "os"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

var logger *slog.Logger

func init() <span class="cov8" title="1">{
        // Initialize structured logger
        opts := &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        }
        
        // Use JSON handler for structured logs
        handler := slog.NewJSONHandler(os.Stdout, opts)
        logger = slog.New(handler)
}</span>

// responseWriter wraps gin.ResponseWriter to capture response body
type responseWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        // Write to both the actual response and our buffer
        w.body.Write(data)
        return w.ResponseWriter.Write(data)
}</span>

// LoggingConfig configures the logging middleware
type LoggingConfig struct {
        LogRequests       bool
        LogResponses      bool
        LogHeaders        bool
        LogRequestBody    bool
        LogResponseBody   bool
        MaxBodySize       int64
        SkipPaths         []string
        SensitiveHeaders  []string
        SensitiveFields   []string
}

// DefaultLoggingConfig returns a default logging configuration
func DefaultLoggingConfig() LoggingConfig <span class="cov8" title="1">{
        return LoggingConfig{
                LogRequests:     true,
                LogResponses:    true,
                LogHeaders:      true,
                LogRequestBody:  true,
                LogResponseBody: true,
                MaxBodySize:     1024 * 1024, // 1MB
                SkipPaths:       []string{"/heartbeat", "/health"},
                SensitiveHeaders: []string{
                        "authorization",
                        "x-firebase-token",
                        "x-nostr-authorization",
                        "cookie",
                },
                SensitiveFields: []string{
                        "password",
                        "token",
                        "secret",
                        "key",
                        "auth",
                },
        }
}</span>

// RequestResponseLogging returns a Gin middleware that logs requests and responses
func RequestResponseLogging(config LoggingConfig) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Skip logging for certain paths
                for _, skipPath := range config.SkipPaths </span><span class="cov8" title="1">{
                        if c.Request.URL.Path == skipPath </span><span class="cov8" title="1">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov8" title="1">start := time.Now()
                correlationID := uuid.New().String()
                c.Set("correlation_id", correlationID)

                // Capture request body if enabled
                var requestBody []byte
                if config.LogRequestBody &amp;&amp; c.Request.Body != nil </span><span class="cov8" title="1">{
                        requestBody, _ = io.ReadAll(c.Request.Body)
                        if len(requestBody) &gt; int(config.MaxBodySize) </span><span class="cov8" title="1">{
                                requestBody = requestBody[:config.MaxBodySize]
                        }</span>
                        // Restore the body for the actual handler
                        <span class="cov8" title="1">c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))</span>
                }

                // Wrap response writer to capture response body
                <span class="cov8" title="1">var responseBody *bytes.Buffer
                if config.LogResponses </span><span class="cov8" title="1">{
                        responseBody = &amp;bytes.Buffer{}
                        writer := &amp;responseWriter{
                                ResponseWriter: c.Writer,
                                body:          responseBody,
                        }
                        c.Writer = writer
                }</span>

                // Log incoming request
                <span class="cov8" title="1">if config.LogRequests </span><span class="cov8" title="1">{
                        logRequest(c, correlationID, requestBody, config)
                }</span>

                // Process request
                <span class="cov8" title="1">c.Next()

                // Calculate processing time
                duration := time.Since(start)

                // Log outgoing response
                if config.LogResponses </span><span class="cov8" title="1">{
                        logResponse(c, correlationID, responseBody.Bytes(), duration, config)
                }</span>
        }
}

func logRequest(c *gin.Context, correlationID string, body []byte, config LoggingConfig) <span class="cov8" title="1">{
        attrs := []slog.Attr{
                slog.String("type", "request"),
                slog.String("correlation_id", correlationID),
                slog.String("method", c.Request.Method),
                slog.String("path", c.Request.URL.Path),
                slog.String("query", c.Request.URL.RawQuery),
                slog.String("remote_addr", c.ClientIP()),
                slog.String("user_agent", c.Request.UserAgent()),
        }

        // Add headers if enabled
        if config.LogHeaders </span><span class="cov8" title="1">{
                headers := make(map[string]string)
                for name, values := range c.Request.Header </span><span class="cov8" title="1">{
                        value := strings.Join(values, ", ")
                        
                        // Mask sensitive headers
                        if isSensitiveHeader(name, config.SensitiveHeaders) </span><span class="cov8" title="1">{
                                value = maskSensitiveData(value)
                        }</span>
                        
                        <span class="cov8" title="1">headers[strings.ToLower(name)] = value</span>
                }
                <span class="cov8" title="1">attrs = append(attrs, slog.Any("headers", headers))</span>
        }

        // Add request body if enabled and present
        <span class="cov8" title="1">if config.LogRequestBody &amp;&amp; len(body) &gt; 0 </span><span class="cov8" title="1">{
                bodyStr := string(body)
                
                // Mask sensitive data in body
                bodyStr = maskSensitiveDataInJSON(bodyStr, config.SensitiveFields)
                
                attrs = append(attrs, slog.String("body", bodyStr))
                attrs = append(attrs, slog.Int("body_size", len(body)))
        }</span>

        <span class="cov8" title="1">logger.LogAttrs(c.Request.Context(), slog.LevelInfo, "HTTP Request", attrs...)</span>
}

func logResponse(c *gin.Context, correlationID string, body []byte, duration time.Duration, config LoggingConfig) <span class="cov8" title="1">{
        attrs := []slog.Attr{
                slog.String("type", "response"),
                slog.String("correlation_id", correlationID),
                slog.Int("status", c.Writer.Status()),
                slog.Int("size", c.Writer.Size()),
                slog.Duration("duration", duration),
                slog.String("duration_ms", duration.String()),
        }

        // Add response headers if enabled
        if config.LogHeaders </span><span class="cov8" title="1">{
                headers := make(map[string]string)
                for name, values := range c.Writer.Header() </span><span class="cov8" title="1">{
                        headers[strings.ToLower(name)] = strings.Join(values, ", ")
                }</span>
                <span class="cov8" title="1">attrs = append(attrs, slog.Any("headers", headers))</span>
        }

        // Add response body if enabled and present
        <span class="cov8" title="1">if config.LogResponseBody &amp;&amp; len(body) &gt; 0 </span><span class="cov8" title="1">{
                bodyStr := string(body)
                
                // Truncate if too large
                if len(body) &gt; int(config.MaxBodySize) </span><span class="cov8" title="1">{
                        bodyStr = bodyStr[:config.MaxBodySize] + "... [truncated]"
                }</span>
                
                // Mask sensitive data in response body
                <span class="cov8" title="1">bodyStr = maskSensitiveDataInJSON(bodyStr, config.SensitiveFields)
                
                attrs = append(attrs, slog.String("body", bodyStr))
                attrs = append(attrs, slog.Int("body_size", len(body)))</span>
        }

        <span class="cov8" title="1">logger.LogAttrs(c.Request.Context(), slog.LevelInfo, "HTTP Response", attrs...)</span>
}

// Helper functions for sensitive data masking
func isSensitiveHeader(name string, sensitiveHeaders []string) bool <span class="cov8" title="1">{
        name = strings.ToLower(name)
        for _, sensitive := range sensitiveHeaders </span><span class="cov8" title="1">{
                if strings.Contains(name, strings.ToLower(sensitive)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func maskSensitiveData(value string) string <span class="cov8" title="1">{
        if len(value) &lt;= 4 </span><span class="cov8" title="1">{
                return "***"
        }</span>
        <span class="cov8" title="1">return value[:2] + strings.Repeat("*", len(value)-4) + value[len(value)-2:]</span>
}

func maskSensitiveDataInJSON(body string, sensitiveFields []string) string <span class="cov8" title="1">{
        for _, field := range sensitiveFields </span><span class="cov8" title="1">{
                // Simple replacement for JSON fields
                // In a production system, you'd want proper JSON parsing with regex
                if strings.Contains(strings.ToLower(body), `"`+strings.ToLower(field)+`":`) </span><span class="cov8" title="1">{
                        // For now, just indicate that sensitive data was masked
                        body = strings.ReplaceAll(body, `"`+field+`"`, `"`+field+`" [MASKED]`)
                }</span>
        }
        <span class="cov8" title="1">return body</span>
}

// GetCorrelationID retrieves the correlation ID from the Gin context
func GetCorrelationID(c *gin.Context) string <span class="cov8" title="1">{
        if id, exists := c.Get("correlation_id"); exists </span><span class="cov8" title="1">{
                return id.(string)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// LogWithCorrelation logs a message with the correlation ID from context
func LogWithCorrelation(c *gin.Context, level slog.Level, msg string, attrs ...slog.Attr) <span class="cov8" title="1">{
        correlationID := GetCorrelationID(c)
        if correlationID != "" </span><span class="cov8" title="1">{
                attrs = append([]slog.Attr{slog.String("correlation_id", correlationID)}, attrs...)
        }</span>
        <span class="cov8" title="1">logger.LogAttrs(c.Request.Context(), level, msg, attrs...)</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "context"
        "fmt"

        "github.com/wavlake/monorepo/internal/models"
)

// CompressionService handles compression version management
type CompressionService struct {
        nostrTrackService NostrTrackServiceInterface
}

// NewCompressionService creates a new compression service
func NewCompressionService(nostrTrackService NostrTrackServiceInterface) *CompressionService <span class="cov8" title="1">{
        return &amp;CompressionService{
                nostrTrackService: nostrTrackService,
        }
}</span>

// RequestCompression requests compression for specific options
func (s *CompressionService) RequestCompression(ctx context.Context, trackID string, options []models.CompressionOption) error <span class="cov8" title="1">{
        // Validate track exists
        track, err := s.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("track not found: %w", err)
        }</span>

        // Mark as having pending compression
        <span class="cov8" title="1">if err := s.nostrTrackService.SetPendingCompression(ctx, trackID, true); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set pending compression: %w", err)
        }</span>

        // In a real implementation, this would queue compression jobs
        // For now, just validate the track exists
        <span class="cov8" title="1">_ = track

        return nil</span>
}

// GetCompressionStatus returns the status of compression for a track
func (s *CompressionService) GetCompressionStatus(ctx context.Context, trackID string) (*models.ProcessingStatus, error) <span class="cov8" title="1">{
        track, err := s.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("track not found: %w", err)
        }</span>

        <span class="cov8" title="1">status := "completed"
        if track.IsProcessing </span><span class="cov8" title="1">{
                status = "processing"
        }</span> else<span class="cov8" title="1"> if track.HasPendingCompression </span><span class="cov8" title="1">{
                status = "queued"
        }</span>

        <span class="cov8" title="1">return &amp;models.ProcessingStatus{
                TrackID:   trackID,
                Status:    status,
                Progress:  100,
                Message:   "Compression status retrieved",
                StartedAt: track.CreatedAt,
        }, nil</span>
}

// AddCompressionVersion adds a new compression version
func (s *CompressionService) AddCompressionVersion(ctx context.Context, trackID string, version models.CompressionVersion) error <span class="cov8" title="1">{
        return s.nostrTrackService.AddCompressionVersion(ctx, trackID, version)
}</span>

// UpdateVersionVisibility updates the visibility of a compression version
func (s *CompressionService) UpdateVersionVisibility(ctx context.Context, trackID, versionID string, isPublic bool) error <span class="cov8" title="1">{
        updates := []models.VersionUpdate{
                {
                        VersionID: versionID,
                        IsPublic:  isPublic,
                },
        }
        return s.nostrTrackService.UpdateCompressionVisibility(ctx, trackID, updates)
}</span>

// GetPublicVersions returns only public compression versions
func (s *CompressionService) GetPublicVersions(ctx context.Context, trackID string) ([]models.CompressionVersion, error) <span class="cov8" title="1">{
        track, err := s.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("track not found: %w", err)
        }</span>

        <span class="cov8" title="1">var publicVersions []models.CompressionVersion
        for _, version := range track.CompressionVersions </span><span class="cov8" title="1">{
                if version.IsPublic </span><span class="cov8" title="1">{
                        publicVersions = append(publicVersions, version)
                }</span>
        }

        <span class="cov8" title="1">return publicVersions, nil</span>
}

// DeleteCompressionVersion deletes a compression version
func (s *CompressionService) DeleteCompressionVersion(ctx context.Context, trackID, versionID string) error <span class="cov8" title="1">{
        // In a real implementation, this would remove the version from storage and update the track
        // For now, just validate the track exists
        _, err := s.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("track not found: %w", err)
        }</span>

        // In practice, would modify the CompressionVersions slice
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"
        "fmt"
        "runtime"
        "time"

        "github.com/wavlake/monorepo/internal/models"
)

// DevelopmentService provides development utilities and debugging
type DevelopmentService struct {
        // Add dependencies as needed
}

// NewDevelopmentService creates a new development service
func NewDevelopmentService() *DevelopmentService <span class="cov0" title="0">{
        return &amp;DevelopmentService{}
}</span>

// ResetDatabase resets the database to a clean state
func (s *DevelopmentService) ResetDatabase(ctx context.Context) error <span class="cov0" title="0">{
        // In a real implementation, this would:
        // - Drop all tables
        // - Run migrations
        // - Clear caches
        // For now, just validate context
        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("context is required")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// SeedTestData seeds the database with test data
func (s *DevelopmentService) SeedTestData(ctx context.Context) error <span class="cov0" title="0">{
        // In a real implementation, this would:
        // - Create test users
        // - Create test tracks
        // - Create test compression versions
        // For now, just validate context
        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("context is required")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetSystemInfo returns system diagnostic information
func (s *DevelopmentService) GetSystemInfo(ctx context.Context) (*models.SystemInfo, error) <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        return &amp;models.SystemInfo{
                Version:     "1.0.0",
                Environment: "development",
                Uptime:      "1h 23m",
                Memory: map[string]string{
                        "alloc":      fmt.Sprintf("%d KB", m.Alloc/1024),
                        "total_alloc": fmt.Sprintf("%d KB", m.TotalAlloc/1024),
                        "sys":        fmt.Sprintf("%d KB", m.Sys/1024),
                        "num_gc":     fmt.Sprintf("%d", m.NumGC),
                },
                Database: map[string]string{
                        "status":      "healthy",
                        "connections": "5/100",
                },
                Storage: map[string]string{
                        "status":    "available",
                        "free_space": "50GB",
                },
                Services: map[string]string{
                        "api":     "running",
                        "workers": "running",
                        "cache":   "running",
                },
        }, nil
}</span>

// ClearCache clears all application caches
func (s *DevelopmentService) ClearCache(ctx context.Context) error <span class="cov0" title="0">{
        // In a real implementation, this would:
        // - Clear Redis cache
        // - Clear in-memory caches
        // - Clear CDN cache
        // For now, just validate context
        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("context is required")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GenerateTestFiles generates test files for development
func (s *DevelopmentService) GenerateTestFiles(ctx context.Context, count int) ([]string, error) <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count must be positive")
        }</span>
        
        <span class="cov0" title="0">files := make([]string, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                files[i] = fmt.Sprintf("test_file_%d.txt", i+1)
        }</span>
        
        <span class="cov0" title="0">return files, nil</span>
}

// SimulateLoad simulates load on the system for testing
func (s *DevelopmentService) SimulateLoad(ctx context.Context, duration time.Duration) error <span class="cov0" title="0">{
        if duration &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("duration must be positive")
        }</span>
        
        // Simple load simulation - just sleep
        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(duration):<span class="cov0" title="0">
                return nil</span>
        }
}

// GetLogs returns system logs for debugging
func (s *DevelopmentService) GetLogs(ctx context.Context, level string, limit int) ([]models.LogEntry, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        
        // Generate sample log entries
        <span class="cov0" title="0">logs := make([]models.LogEntry, limit)
        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                logs[i] = models.LogEntry{
                        Level:     level,
                        Message:   fmt.Sprintf("Sample log entry %d", i+1),
                        Timestamp: time.Now().Add(-time.Duration(i) * time.Minute),
                        Service:   "api",
                        Data: map[string]interface{}{
                                "request_id": fmt.Sprintf("req_%d", i+1),
                                "user_id":    fmt.Sprintf("user_%d", (i%10)+1),
                        },
                }
        }</span>
        
        <span class="cov0" title="0">return logs, nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/wavlake/monorepo/internal/models"
)

// FileServerService handles file server operations
type FileServerService struct {
        basePath     string
        tokenService TokenServiceInterface
}

// NewFileServerService creates a new file server service
func NewFileServerService(basePath string, tokenService TokenServiceInterface) *FileServerService <span class="cov0" title="0">{
        return &amp;FileServerService{
                basePath:     basePath,
                tokenService: tokenService,
        }
}</span>

// UploadFile uploads a file to the file server
func (s *FileServerService) UploadFile(ctx context.Context, path string, data io.Reader, contentType string) (*models.FileMetadata, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, path)
        
        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Create the file
        <span class="cov0" title="0">file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Copy data to file
        size, err := io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.FileMetadata{
                Name:        filepath.Base(path),
                Size:        size,
                ContentType: contentType,
                Bucket:      "file-server",
                URL:         "/file/" + path,
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }, nil</span>
}

// DownloadFile downloads a file from the file server
func (s *FileServerService) DownloadFile(ctx context.Context, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, path)
        
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return file, nil</span>
}

// DeleteFile deletes a file from the file server
func (s *FileServerService) DeleteFile(ctx context.Context, path string) error <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, path)
        
        if err := os.Remove(fullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ListFiles lists files with the given prefix
func (s *FileServerService) ListFiles(ctx context.Context, prefix string) ([]string, error) <span class="cov0" title="0">{
        searchPath := filepath.Join(s.basePath, prefix)
        
        var files []string
        err := filepath.Walk(searchPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        // Get relative path from base
                        relPath, err := filepath.Rel(s.basePath, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">files = append(files, relPath)</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>
        
        <span class="cov0" title="0">return files, nil</span>
}

// GetFileMetadata gets metadata for a file
func (s *FileServerService) GetFileMetadata(ctx context.Context, path string) (*models.FileMetadata, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, path)
        
        info, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get file info: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;models.FileMetadata{
                Name:        info.Name(),
                Size:        info.Size(),
                ContentType: "application/octet-stream", // Default, would need mime type detection
                Bucket:      "file-server",
                URL:         "/file/" + path,
                CreatedAt:   info.ModTime(),
                UpdatedAt:   info.ModTime(),
        }, nil</span>
}

// GenerateUploadToken generates a token for file upload
func (s *FileServerService) GenerateUploadToken(ctx context.Context, path, userID string, expiration time.Duration) (*models.FileUploadToken, error) <span class="cov0" title="0">{
        return s.tokenService.GenerateUploadToken(ctx, path, userID, expiration)
}</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/wavlake/monorepo/internal/models"
)

// MockStorageService provides GCS-compatible mock storage for development
type MockStorageService struct {
        basePath string
}

// NewMockStorageService creates a new mock storage service
func NewMockStorageService(basePath string) *MockStorageService <span class="cov0" title="0">{
        return &amp;MockStorageService{
                basePath: basePath,
        }
}</span>

// UploadFile uploads a file to mock storage
func (s *MockStorageService) UploadFile(ctx context.Context, bucket, path string, data io.Reader, contentType string) (*models.FileMetadata, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, bucket, path)
        
        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Create the file
        <span class="cov0" title="0">file, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Copy data to file
        size, err := io.Copy(file, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.FileMetadata{
                Name:        filepath.Base(path),
                Size:        size,
                ContentType: contentType,
                Bucket:      bucket,
                URL:         fmt.Sprintf("/mock-storage/%s/%s", bucket, path),
                CreatedAt:   time.Now(),
                UpdatedAt:   time.Now(),
        }, nil</span>
}

// DownloadFile downloads a file from mock storage
func (s *MockStorageService) DownloadFile(ctx context.Context, bucket, path string) (io.ReadCloser, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, bucket, path)
        
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return file, nil</span>
}

// DeleteFile deletes a file from mock storage
func (s *MockStorageService) DeleteFile(ctx context.Context, bucket, path string) error <span class="cov0" title="0">{
        fullPath := filepath.Join(s.basePath, bucket, path)
        
        if err := os.Remove(fullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ListFiles lists files in mock storage with the given prefix
func (s *MockStorageService) ListFiles(ctx context.Context, bucket, prefix string) ([]string, error) <span class="cov0" title="0">{
        searchPath := filepath.Join(s.basePath, bucket, prefix)
        
        var files []string
        err := filepath.Walk(searchPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        // Get relative path from bucket root
                        bucketRoot := filepath.Join(s.basePath, bucket)
                        relPath, err := filepath.Rel(bucketRoot, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">files = append(files, relPath)</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list files: %w", err)
        }</span>
        
        <span class="cov0" title="0">return files, nil</span>
}

// GetBucketInfo returns information about a mock storage bucket
func (s *MockStorageService) GetBucketInfo(ctx context.Context, bucket string) (*models.BucketInfo, error) <span class="cov0" title="0">{
        bucketPath := filepath.Join(s.basePath, bucket)
        
        // Check if bucket exists
        if _, err := os.Stat(bucketPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bucket not found: %s", bucket)
        }</span>
        
        <span class="cov0" title="0">return &amp;models.BucketInfo{
                Name:         bucket,
                Location:     "mock-region",
                StorageClass: "STANDARD",
                CreatedAt:    time.Now(), // Would need to track actual creation time
        }, nil</span>
}

// CreateBucket creates a new mock storage bucket
func (s *MockStorageService) CreateBucket(ctx context.Context, bucket, location string) error <span class="cov0" title="0">{
        bucketPath := filepath.Join(s.basePath, bucket)
        
        // Check if bucket already exists
        if _, err := os.Stat(bucketPath); err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket already exists: %s", bucket)
        }</span>
        
        // Create bucket directory
        <span class="cov0" title="0">if err := os.MkdirAll(bucketPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create bucket: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// HealthCheck checks if the mock storage service is healthy
func (s *MockStorageService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Check if base path is accessible
        if _, err := os.Stat(s.basePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mock storage path not accessible: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "time"

        "cloud.google.com/go/firestore"
        "github.com/google/uuid"
        "github.com/wavlake/monorepo/internal/models"
        "google.golang.org/api/iterator"
)

type NostrTrackService struct {
        firestoreClient *firestore.Client
        storageService  StorageServiceInterface
        pathConfig      StoragePathConfigInterface
}

func NewNostrTrackService(firestoreClient *firestore.Client, storageService StorageServiceInterface, pathConfig StoragePathConfigInterface) *NostrTrackService <span class="cov0" title="0">{
        return &amp;NostrTrackService{
                firestoreClient: firestoreClient,
                storageService:  storageService,
                pathConfig:      pathConfig,
        }
}</span>

// CreateTrack creates a new NostrTrack record and returns a presigned upload URL
func (s *NostrTrackService) CreateTrack(ctx context.Context, pubkey, firebaseUID, extension string) (*models.NostrTrack, error) <span class="cov0" title="0">{
        trackID := uuid.New().String()
        now := time.Now()

        // Generate storage object names using path configuration
        originalObjectName := s.pathConfig.GetOriginalPath(trackID, extension)

        // Generate presigned URL for upload (valid for 1 hour)
        presignedURL, err := s.storageService.GeneratePresignedURL(ctx, originalObjectName, time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>

        // Create the track record
        <span class="cov0" title="0">track := &amp;models.NostrTrack{
                ID:                    trackID,
                FirebaseUID:           firebaseUID,
                Pubkey:                pubkey,
                OriginalURL:           s.storageService.GetPublicURL(originalObjectName),
                PresignedURL:          presignedURL,
                Extension:             extension,
                IsProcessing:          true,
                IsCompressed:          false,
                CompressionVersions:   []models.CompressionVersion{}, // Initialize empty slice
                HasPendingCompression: false,
                Deleted:               false,
                CreatedAt:             now,
                UpdatedAt:             now,
        }

        // Save to Firestore
        _, err = s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Set(ctx, track)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save track to firestore: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Created new Nostr track with ID: %s for pubkey: %s", trackID, pubkey)
        return track, nil</span>
}

// GetTrack retrieves a track by ID
func (s *NostrTrackService) GetTrack(ctx context.Context, trackID string) (*models.NostrTrack, error) <span class="cov0" title="0">{
        doc, err := s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get track: %w", err)
        }</span>

        <span class="cov0" title="0">var track models.NostrTrack
        if err := doc.DataTo(&amp;track); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode track: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;track, nil</span>
}

// GetTracksByPubkey retrieves all tracks for a given pubkey
func (s *NostrTrackService) GetTracksByPubkey(ctx context.Context, pubkey string) ([]*models.NostrTrack, error) <span class="cov0" title="0">{
        query := s.firestoreClient.Collection("nostr_tracks").
                Where("pubkey", "==", pubkey).
                Where("deleted", "==", false).
                OrderBy("created_at", firestore.Desc)

        iter := query.Documents(ctx)
        defer iter.Stop()

        var tracks []*models.NostrTrack
        for </span><span class="cov0" title="0">{
                doc, err := iter.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to iterate tracks: %w", err)
                }</span>

                <span class="cov0" title="0">var track models.NostrTrack
                if err := doc.DataTo(&amp;track); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to decode track %s: %v", doc.Ref.ID, err)
                        continue</span>
                }

                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

// GetTracksByFirebaseUID retrieves all tracks for a given Firebase UID
func (s *NostrTrackService) GetTracksByFirebaseUID(ctx context.Context, firebaseUID string) ([]*models.NostrTrack, error) <span class="cov0" title="0">{
        query := s.firestoreClient.Collection("nostr_tracks").
                Where("firebase_uid", "==", firebaseUID).
                Where("deleted", "==", false).
                OrderBy("created_at", firestore.Desc)

        iter := query.Documents(ctx)
        defer iter.Stop()

        var tracks []*models.NostrTrack
        for </span><span class="cov0" title="0">{
                doc, err := iter.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to iterate tracks: %w", err)
                }</span>

                <span class="cov0" title="0">var track models.NostrTrack
                if err := doc.DataTo(&amp;track); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to decode track %s: %v", doc.Ref.ID, err)
                        continue</span>
                }

                <span class="cov0" title="0">tracks = append(tracks, &amp;track)</span>
        }

        <span class="cov0" title="0">return tracks, nil</span>
}

// UpdateTrack updates track metadata
func (s *NostrTrackService) UpdateTrack(ctx context.Context, trackID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        updates["updated_at"] = time.Now()

        var updatePaths []firestore.Update
        for path, value := range updates </span><span class="cov0" title="0">{
                updatePaths = append(updatePaths, firestore.Update{Path: path, Value: value})
        }</span>

        <span class="cov0" title="0">_, err := s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Update(ctx, updatePaths)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update track: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkTrackAsProcessed updates track status after processing
func (s *NostrTrackService) MarkTrackAsProcessed(ctx context.Context, trackID string, size int64, duration int) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "is_processing": false,
                "size":          size,
                "duration":      duration,
                "updated_at":    time.Now(),
        }

        return s.UpdateTrack(ctx, trackID, updates)
}</span>

// MarkTrackAsCompressed updates track with compressed file info
func (s *NostrTrackService) MarkTrackAsCompressed(ctx context.Context, trackID, compressedURL string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "compressed_url": compressedURL,
                "is_compressed":  true,
                "updated_at":     time.Now(),
        }

        return s.UpdateTrack(ctx, trackID, updates)
}</span>

// DeleteTrack soft deletes a track
func (s *NostrTrackService) DeleteTrack(ctx context.Context, trackID string) error <span class="cov0" title="0">{
        updates := map[string]interface{}{
                "deleted":    true,
                "updated_at": time.Now(),
        }

        return s.UpdateTrack(ctx, trackID, updates)
}</span>

// HardDeleteTrack permanently deletes a track and its files
func (s *NostrTrackService) HardDeleteTrack(ctx context.Context, trackID string) error <span class="cov0" title="0">{
        // Get track first to know which files to delete
        track, err := s.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get track for deletion: %w", err)
        }</span>

        // Delete files from storage using path configuration
        <span class="cov0" title="0">originalObjectName := s.pathConfig.GetOriginalPath(trackID, track.Extension)
        if err := s.storageService.DeleteObject(ctx, originalObjectName); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to delete original file for track %s: %v", trackID, err)
        }</span>

        <span class="cov0" title="0">if track.CompressedURL != "" </span><span class="cov0" title="0">{
                compressedObjectName := s.pathConfig.GetCompressedPath(trackID)
                if err := s.storageService.DeleteObject(ctx, compressedObjectName); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to delete compressed file for track %s: %v", trackID, err)
                }</span>
        }

        // Delete from Firestore
        <span class="cov0" title="0">_, err = s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Delete(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete track from firestore: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Hard deleted track %s", trackID)
        return nil</span>
}

// UpdateCompressionVisibility updates which compression versions are public
func (s *NostrTrackService) UpdateCompressionVisibility(ctx context.Context, trackID string, updates []models.VersionUpdate) error <span class="cov0" title="0">{
        // Get current track
        track, err := s.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get track: %w", err)
        }</span>

        // Update visibility for specified versions
        <span class="cov0" title="0">for i, version := range track.CompressionVersions </span><span class="cov0" title="0">{
                for _, update := range updates </span><span class="cov0" title="0">{
                        if version.ID == update.VersionID </span><span class="cov0" title="0">{
                                track.CompressionVersions[i].IsPublic = update.IsPublic
                                break</span>
                        }
                }
        }

        // Save updated track
        <span class="cov0" title="0">_, err = s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Set(ctx, track)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update track: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated compression visibility for track %s", trackID)
        return nil</span>
}

// AddCompressionVersion adds a new compression version to a track
func (s *NostrTrackService) AddCompressionVersion(ctx context.Context, trackID string, version models.CompressionVersion) error <span class="cov0" title="0">{
        // Get current track
        track, err := s.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get track: %w", err)
        }</span>

        // Check if version with same ID already exists
        <span class="cov0" title="0">for i, existing := range track.CompressionVersions </span><span class="cov0" title="0">{
                if existing.ID == version.ID </span><span class="cov0" title="0">{
                        // Update existing version
                        track.CompressionVersions[i] = version
                        log.Printf("Updated existing compression version %s for track %s", version.ID, trackID)

                        // Save updated track
                        _, err = s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Set(ctx, track)
                        return err
                }</span>
        }

        // Add new version
        <span class="cov0" title="0">track.CompressionVersions = append(track.CompressionVersions, version)
        track.HasPendingCompression = false // Clear pending flag

        // Save updated track
        _, err = s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Set(ctx, track)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update track: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Added compression version %s for track %s", version.ID, trackID)
        return nil</span>
}

// SetPendingCompression marks a track as having pending compression requests
func (s *NostrTrackService) SetPendingCompression(ctx context.Context, trackID string, pending bool) error <span class="cov0" title="0">{
        updates := []firestore.Update{
                {Path: "has_pending_compression", Value: pending},
                {Path: "updated_at", Value: time.Now()},
        }

        _, err := s.firestoreClient.Collection("nostr_tracks").Doc(trackID).Update(ctx, updates)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update pending compression status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq" // PostgreSQL driver
        "github.com/wavlake/monorepo/internal/models"
)

// PostgreSQL Service for legacy database access
//
// IMPORTANT: The legacy database uses a table named "user" which is a PostgreSQL reserved keyword.
// All queries referencing this table MUST use quoted identifiers: "user" (with quotes)
// Failure to use quotes will result in cryptic "column does not exist" errors.

type PostgresService struct {
        db *sql.DB
}

// NewPostgresService creates a new PostgreSQL service instance
func NewPostgresService(db *sql.DB) *PostgresService <span class="cov0" title="0">{
        return &amp;PostgresService{
                db: db,
        }
}</span>

// GetUserByFirebaseUID retrieves a user by their Firebase UID
func (p *PostgresService) GetUserByFirebaseUID(ctx context.Context, firebaseUID string) (*models.LegacyUser, error) <span class="cov0" title="0">{
        // Note: "user" table name requires quotes because 'user' is a PostgreSQL reserved keyword.
        // Without quotes, PostgreSQL interprets 'user' as a keyword rather than a table identifier,
        // resulting in confusing "column does not exist" errors instead of the actual table access.
        query := `
                SELECT id, name, COALESCE(lightning_address, '') as lightning_address, 
                       COALESCE(msat_balance, 0) as msat_balance, COALESCE(amp_msat, 1000) as amp_msat,
                       COALESCE(artwork_url, '') as artwork_url, COALESCE(profile_url, '') as profile_url,
                       COALESCE(is_locked, false) as is_locked, created_at, updated_at
                FROM "user" 
                WHERE id = $1 AND NOT COALESCE(is_locked, false)
        `

        var user models.LegacyUser
        err := p.db.QueryRowContext(ctx, query, firebaseUID).Scan(
                &amp;user.ID,
                &amp;user.Name,
                &amp;user.LightningAddress,
                &amp;user.MSatBalance,
                &amp;user.AmpMsat,
                &amp;user.ArtworkURL,
                &amp;user.ProfileURL,
                &amp;user.IsLocked,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserTracks retrieves all tracks for a user by Firebase UID
func (p *PostgresService) GetUserTracks(ctx context.Context, firebaseUID string) ([]models.LegacyTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT t.id, t.artist_id, t.album_id, t.title, t."order", 
                       COALESCE(t.play_count, 0) as play_count, COALESCE(t.msat_total, 0) as msat_total,
                       t.live_url, COALESCE(t.raw_url, '') as raw_url, 
                       COALESCE(t.size, 0) as size, COALESCE(t.duration, 0) as duration,
                       COALESCE(t.is_processing, false) as is_processing, COALESCE(t.is_draft, false) as is_draft,
                       COALESCE(t.is_explicit, false) as is_explicit, COALESCE(t.compressor_error, false) as compressor_error,
                       COALESCE(t.deleted, false) as deleted, COALESCE(t.lyrics, '') as lyrics,
                       t.created_at, t.updated_at, t.published_at
                FROM track t
                JOIN album al ON t.album_id = al.id
                JOIN artist ar ON al.artist_id = ar.id
                WHERE ar.user_id = $1 AND NOT COALESCE(t.deleted, false)
                ORDER BY t.created_at DESC
        `

        rows, err := p.db.QueryContext(ctx, query, firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query tracks: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []models.LegacyTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track models.LegacyTrack
                err := rows.Scan(
                        &amp;track.ID,
                        &amp;track.ArtistID,
                        &amp;track.AlbumID,
                        &amp;track.Title,
                        &amp;track.Order,
                        &amp;track.PlayCount,
                        &amp;track.MSatTotal,
                        &amp;track.LiveURL,
                        &amp;track.RawURL,
                        &amp;track.Size,
                        &amp;track.Duration,
                        &amp;track.IsProcessing,
                        &amp;track.IsDraft,
                        &amp;track.IsExplicit,
                        &amp;track.CompressorError,
                        &amp;track.Deleted,
                        &amp;track.Lyrics,
                        &amp;track.CreatedAt,
                        &amp;track.UpdatedAt,
                        &amp;track.PublishedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan track: %w", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate tracks: %w", err)
        }</span>

        <span class="cov0" title="0">return tracks, nil</span>
}

// GetUserArtists retrieves all artists for a user by Firebase UID
func (p *PostgresService) GetUserArtists(ctx context.Context, firebaseUID string) ([]models.LegacyArtist, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, name, COALESCE(artwork_url, '') as artwork_url,
                       artist_url, COALESCE(bio, '') as bio, COALESCE(twitter, '') as twitter,
                       COALESCE(instagram, '') as instagram, COALESCE(youtube, '') as youtube,
                       COALESCE(website, '') as website, COALESCE(npub, '') as npub,
                       COALESCE(verified, false) as verified, COALESCE(deleted, false) as deleted,
                       COALESCE(msat_total, 0) as msat_total, created_at, updated_at
                FROM artist 
                WHERE user_id = $1 AND NOT COALESCE(deleted, false)
                ORDER BY created_at DESC
        `

        rows, err := p.db.QueryContext(ctx, query, firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query artists: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var artists []models.LegacyArtist
        for rows.Next() </span><span class="cov0" title="0">{
                var artist models.LegacyArtist
                err := rows.Scan(
                        &amp;artist.ID,
                        &amp;artist.UserID,
                        &amp;artist.Name,
                        &amp;artist.ArtworkURL,
                        &amp;artist.ArtistURL,
                        &amp;artist.Bio,
                        &amp;artist.Twitter,
                        &amp;artist.Instagram,
                        &amp;artist.Youtube,
                        &amp;artist.Website,
                        &amp;artist.Npub,
                        &amp;artist.Verified,
                        &amp;artist.Deleted,
                        &amp;artist.MSatTotal,
                        &amp;artist.CreatedAt,
                        &amp;artist.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan artist: %w", err)
                }</span>
                <span class="cov0" title="0">artists = append(artists, artist)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate artists: %w", err)
        }</span>

        <span class="cov0" title="0">return artists, nil</span>
}

// GetUserAlbums retrieves all albums for a user by Firebase UID
func (p *PostgresService) GetUserAlbums(ctx context.Context, firebaseUID string) ([]models.LegacyAlbum, error) <span class="cov0" title="0">{
        query := `
                SELECT al.id, al.artist_id, al.title, COALESCE(al.artwork_url, '') as artwork_url,
                       COALESCE(al.description, '') as description, COALESCE(al.genre_id, 0) as genre_id,
                       COALESCE(al.subgenre_id, 0) as subgenre_id, COALESCE(al.is_draft, false) as is_draft,
                       COALESCE(al.is_single, false) as is_single, COALESCE(al.deleted, false) as deleted,
                       COALESCE(al.msat_total, 0) as msat_total, COALESCE(al.is_feed_published, true) as is_feed_published,
                       al.published_at, al.created_at, al.updated_at
                FROM album al
                JOIN artist ar ON al.artist_id = ar.id
                WHERE ar.user_id = $1 AND NOT COALESCE(al.deleted, false)
                ORDER BY al.created_at DESC
        `

        rows, err := p.db.QueryContext(ctx, query, firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query albums: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var albums []models.LegacyAlbum
        for rows.Next() </span><span class="cov0" title="0">{
                var album models.LegacyAlbum
                err := rows.Scan(
                        &amp;album.ID,
                        &amp;album.ArtistID,
                        &amp;album.Title,
                        &amp;album.ArtworkURL,
                        &amp;album.Description,
                        &amp;album.GenreID,
                        &amp;album.SubgenreID,
                        &amp;album.IsDraft,
                        &amp;album.IsSingle,
                        &amp;album.Deleted,
                        &amp;album.MSatTotal,
                        &amp;album.IsFeedPublished,
                        &amp;album.PublishedAt,
                        &amp;album.CreatedAt,
                        &amp;album.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan album: %w", err)
                }</span>
                <span class="cov0" title="0">albums = append(albums, album)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate albums: %w", err)
        }</span>

        <span class="cov0" title="0">return albums, nil</span>
}

// GetTracksByArtist retrieves all tracks for a specific artist
func (p *PostgresService) GetTracksByArtist(ctx context.Context, artistID string) ([]models.LegacyTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT t.id, t.artist_id, t.album_id, t.title, t."order", 
                       COALESCE(t.play_count, 0) as play_count, COALESCE(t.msat_total, 0) as msat_total,
                       t.live_url, COALESCE(t.raw_url, '') as raw_url, 
                       COALESCE(t.size, 0) as size, COALESCE(t.duration, 0) as duration,
                       COALESCE(t.is_processing, false) as is_processing, COALESCE(t.is_draft, false) as is_draft,
                       COALESCE(t.is_explicit, false) as is_explicit, COALESCE(t.compressor_error, false) as compressor_error,
                       COALESCE(t.deleted, false) as deleted, COALESCE(t.lyrics, '') as lyrics,
                       t.created_at, t.updated_at, t.published_at
                FROM track t
                WHERE t.artist_id = $1 AND NOT COALESCE(t.deleted, false)
                ORDER BY t."order", t.created_at
        `

        rows, err := p.db.QueryContext(ctx, query, artistID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query tracks by artist: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []models.LegacyTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track models.LegacyTrack
                err := rows.Scan(
                        &amp;track.ID,
                        &amp;track.ArtistID,
                        &amp;track.AlbumID,
                        &amp;track.Title,
                        &amp;track.Order,
                        &amp;track.PlayCount,
                        &amp;track.MSatTotal,
                        &amp;track.LiveURL,
                        &amp;track.RawURL,
                        &amp;track.Size,
                        &amp;track.Duration,
                        &amp;track.IsProcessing,
                        &amp;track.IsDraft,
                        &amp;track.IsExplicit,
                        &amp;track.CompressorError,
                        &amp;track.Deleted,
                        &amp;track.Lyrics,
                        &amp;track.CreatedAt,
                        &amp;track.UpdatedAt,
                        &amp;track.PublishedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan track: %w", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate tracks: %w", err)
        }</span>

        <span class="cov0" title="0">return tracks, nil</span>
}

// GetTracksByAlbum retrieves all tracks for a specific album
func (p *PostgresService) GetTracksByAlbum(ctx context.Context, albumID string) ([]models.LegacyTrack, error) <span class="cov0" title="0">{
        query := `
                SELECT id, artist_id, album_id, title, "order", 
                       COALESCE(play_count, 0) as play_count, COALESCE(msat_total, 0) as msat_total,
                       live_url, COALESCE(raw_url, '') as raw_url, 
                       COALESCE(size, 0) as size, COALESCE(duration, 0) as duration,
                       COALESCE(is_processing, false) as is_processing, COALESCE(is_draft, false) as is_draft,
                       COALESCE(is_explicit, false) as is_explicit, COALESCE(compressor_error, false) as compressor_error,
                       COALESCE(deleted, false) as deleted, COALESCE(lyrics, '') as lyrics,
                       created_at, updated_at, published_at
                FROM track 
                WHERE album_id = $1 AND NOT COALESCE(deleted, false)
                ORDER BY "order", created_at
        `

        rows, err := p.db.QueryContext(ctx, query, albumID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query tracks by album: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tracks []models.LegacyTrack
        for rows.Next() </span><span class="cov0" title="0">{
                var track models.LegacyTrack
                err := rows.Scan(
                        &amp;track.ID,
                        &amp;track.ArtistID,
                        &amp;track.AlbumID,
                        &amp;track.Title,
                        &amp;track.Order,
                        &amp;track.PlayCount,
                        &amp;track.MSatTotal,
                        &amp;track.LiveURL,
                        &amp;track.RawURL,
                        &amp;track.Size,
                        &amp;track.Duration,
                        &amp;track.IsProcessing,
                        &amp;track.IsDraft,
                        &amp;track.IsExplicit,
                        &amp;track.CompressorError,
                        &amp;track.Deleted,
                        &amp;track.Lyrics,
                        &amp;track.CreatedAt,
                        &amp;track.UpdatedAt,
                        &amp;track.PublishedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan track: %w", err)
                }</span>
                <span class="cov0" title="0">tracks = append(tracks, track)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate tracks: %w", err)
        }</span>

        <span class="cov0" title="0">return tracks, nil</span>
}

// Ensure PostgresService implements the interface
var _ PostgresServiceInterface = (*PostgresService)(nil)</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "github.com/google/uuid"
        "github.com/wavlake/monorepo/internal/models"
        "github.com/wavlake/monorepo/internal/utils"
)

type ProcessingService struct {
        storageService    StorageServiceInterface
        nostrTrackService *NostrTrackService
        audioProcessor    *utils.AudioProcessor
        tempDir           string
        pathConfig        *utils.StoragePathConfig
}

func NewProcessingService(storageService StorageServiceInterface, nostrTrackService *NostrTrackService, audioProcessor *utils.AudioProcessor, tempDir string) *ProcessingService <span class="cov0" title="0">{
        return &amp;ProcessingService{
                storageService:    storageService,
                nostrTrackService: nostrTrackService,
                audioProcessor:    audioProcessor,
                tempDir:           tempDir,
                pathConfig:        utils.GetStoragePathConfig(),
        }
}</span>

// ProcessTrack downloads, analyzes, and compresses an uploaded track
func (p *ProcessingService) ProcessTrack(ctx context.Context, trackID string) error <span class="cov0" title="0">{
        log.Printf("Starting processing for track %s", trackID)

        // Get track info
        track, err := p.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get track: %w", err)
        }</span>

        // Create temp files
        <span class="cov0" title="0">originalPath := filepath.Join(p.tempDir, fmt.Sprintf("%s_original.%s", trackID, track.Extension))
        compressedPath := filepath.Join(p.tempDir, fmt.Sprintf("%s_compressed.mp3", trackID))

        defer func() </span><span class="cov0" title="0">{
                _ = os.Remove(originalPath)   // #nosec G104 -- Cleanup operation, errors not critical
                _ = os.Remove(compressedPath) // #nosec G104 -- Cleanup operation, errors not critical
        }</span>()

        // Download original file from GCS
        <span class="cov0" title="0">if err := p.downloadFile(ctx, track.OriginalURL, originalPath); err != nil </span><span class="cov0" title="0">{
                return p.markProcessingFailed(ctx, trackID, fmt.Sprintf("download failed: %v", err))
        }</span>

        // Validate it's a valid audio file
        <span class="cov0" title="0">if err := p.audioProcessor.ValidateAudioFile(ctx, originalPath); err != nil </span><span class="cov0" title="0">{
                return p.markProcessingFailed(ctx, trackID, fmt.Sprintf("invalid audio file: %v", err))
        }</span>

        // Get audio metadata
        <span class="cov0" title="0">audioInfo, err := p.audioProcessor.GetAudioInfo(ctx, originalPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not get audio info for %s: %v", trackID, err)
                // Continue processing even if we can't get metadata
        }</span>

        // Compress the audio with default options
        <span class="cov0" title="0">defaultOptions := models.CompressionOption{
                Bitrate:    128,
                Format:     "mp3",
                Quality:    "medium",
                SampleRate: 44100,
        }
        if err := p.audioProcessor.CompressAudio(ctx, originalPath, compressedPath, defaultOptions); err != nil </span><span class="cov0" title="0">{
                return p.markProcessingFailed(ctx, trackID, fmt.Sprintf("compression failed: %v", err))
        }</span>

        // Upload compressed file to GCS
        <span class="cov0" title="0">compressedObjectName := p.pathConfig.GetCompressedPath(trackID)
        compressedFile, err := os.Open(compressedPath) // #nosec G304 -- Opening controlled temp file for upload
        if err != nil </span><span class="cov0" title="0">{
                return p.markProcessingFailed(ctx, trackID, fmt.Sprintf("failed to open compressed file: %v", err))
        }</span>
        <span class="cov0" title="0">defer compressedFile.Close()

        if err := p.storageService.UploadObject(ctx, compressedObjectName, compressedFile, "audio/mpeg"); err != nil </span><span class="cov0" title="0">{
                return p.markProcessingFailed(ctx, trackID, fmt.Sprintf("failed to upload compressed file: %v", err))
        }</span>

        <span class="cov0" title="0">compressedURL := p.storageService.GetPublicURL(compressedObjectName)

        // Update track with processing results (legacy fields for backwards compatibility)
        updates := map[string]interface{}{
                "is_processing":  false,
                "is_compressed":  true,
                "compressed_url": compressedURL,
        }

        if audioInfo != nil </span><span class="cov0" title="0">{
                updates["size"] = audioInfo.Size
                updates["duration"] = audioInfo.Duration
        }</span>

        <span class="cov0" title="0">if err := p.nostrTrackService.UpdateTrack(ctx, trackID, updates); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update track %s after processing: %v", trackID, err)
                // Don't return error since processing succeeded
        }</span>

        // Also add as a compression version for new system compatibility
        <span class="cov0" title="0">defaultVersion := models.CompressionVersion{
                ID:         "default-128k-mp3",
                URL:        compressedURL,
                Bitrate:    128,
                Format:     "mp3",
                Quality:    "medium",
                SampleRate: 44100,
                Size:       0,    // Will be updated if we can get file info
                IsPublic:   true, // Default compressed version is public for backwards compatibility
                CreatedAt:  time.Now(),
                Options: models.CompressionOption{
                        Bitrate:    128,
                        Format:     "mp3",
                        Quality:    "medium",
                        SampleRate: 44100,
                },
        }

        // Try to get compressed file size
        if compressedInfo, err := os.Stat(compressedPath); err == nil </span><span class="cov0" title="0">{
                defaultVersion.Size = compressedInfo.Size()
        }</span>

        // Add default compression version (ignore errors to maintain backwards compatibility)
        <span class="cov0" title="0">if err := p.nostrTrackService.AddCompressionVersion(ctx, trackID, defaultVersion); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to add default compression version for track %s: %v", trackID, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully processed track %s", trackID)
        return nil</span>
}

// downloadFile downloads a file from a URL to local path
func (p *ProcessingService) downloadFile(ctx context.Context, url, filePath string) error <span class="cov0" title="0">{
        // For GCS URLs, we can use the storage client directly
        // This is more efficient than HTTP download for files in the same project

        // Create temp file
        tempFile, err := os.Create(filePath) // #nosec G304 -- Creating controlled temp file for processing
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer tempFile.Close()

        // Extract object name from URL
        // URL format: https://storage.googleapis.com/bucket/object
        // We need to get the object name part
        objectName := ""
        if len(url) &gt; 0 </span><span class="cov0" title="0">{
                // Simple extraction - in production you might want more robust parsing
                parts := filepath.Base(url)
                if track, err := p.nostrTrackService.GetTrack(ctx, parts[:len(parts)-len(filepath.Ext(parts))]); err == nil </span><span class="cov0" title="0">{
                        objectName = p.pathConfig.GetOriginalPath(track.ID, track.Extension)
                }</span>
        }

        <span class="cov0" title="0">if objectName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("could not determine object name from URL")
        }</span>

        // Download from storage
        <span class="cov0" title="0">reader, err := p.storageService.GetObjectReader(ctx, objectName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create storage reader: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // Copy to temp file
        if _, err := tempFile.ReadFrom(reader); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// markProcessingFailed marks a track as failed processing
func (p *ProcessingService) markProcessingFailed(ctx context.Context, trackID, errorMsg string) error <span class="cov0" title="0">{
        log.Printf("Processing failed for track %s: %s", trackID, errorMsg)

        updates := map[string]interface{}{
                "is_processing": false,
                "error":         errorMsg,
        }

        return p.nostrTrackService.UpdateTrack(ctx, trackID, updates)
}</span>

// ProcessTrackAsync starts track processing in a goroutine
func (p *ProcessingService) ProcessTrackAsync(ctx context.Context, trackID string) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                // Create a background context with timeout
                processCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
                defer cancel()

                if err := p.ProcessTrack(processCtx, trackID); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Async processing failed for track %s: %v", trackID, err)
                }</span>
        }()
}

// RequestCompressionVersions queues multiple compression jobs for a track
func (p *ProcessingService) RequestCompressionVersions(ctx context.Context, trackID string, compressionOptions []models.CompressionOption) error <span class="cov0" title="0">{
        log.Printf("Requesting compression versions for track %s with %d options", trackID, len(compressionOptions))

        // Mark track as having pending compression
        if err := p.nostrTrackService.SetPendingCompression(ctx, trackID, true); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to mark track as pending compression: %w", err)
        }</span>

        // Process each compression option asynchronously
        <span class="cov0" title="0">for _, option := range compressionOptions </span><span class="cov0" title="0">{
                p.ProcessCompressionAsync(ctx, trackID, option)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProcessCompressionAsync processes a single compression option in background
func (p *ProcessingService) ProcessCompressionAsync(ctx context.Context, trackID string, option models.CompressionOption) <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                // Create a background context with timeout
                processCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
                defer cancel()

                if err := p.ProcessCompression(processCtx, trackID, option); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Async compression failed for track %s (option: %+v): %v", trackID, option, err)
                }</span>
        }()
}

// ProcessCompression creates a single compressed version of a track
func (p *ProcessingService) ProcessCompression(ctx context.Context, trackID string, option models.CompressionOption) error <span class="cov0" title="0">{
        versionID := uuid.New().String()
        log.Printf("Starting compression for track %s, version %s (bitrate: %d, format: %s)", trackID, versionID, option.Bitrate, option.Format)

        // Get track info
        track, err := p.nostrTrackService.GetTrack(ctx, trackID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get track: %w", err)
        }</span>

        // Create temp files
        <span class="cov0" title="0">originalPath := filepath.Join(p.tempDir, fmt.Sprintf("%s_original.%s", trackID, track.Extension))
        compressedPath := filepath.Join(p.tempDir, fmt.Sprintf("%s_%s_compressed.%s", trackID, versionID, option.Format))

        defer func() </span><span class="cov0" title="0">{
                _ = os.Remove(originalPath)   // #nosec G104 -- Cleanup operation, errors not critical
                _ = os.Remove(compressedPath) // #nosec G104 -- Cleanup operation, errors not critical
        }</span>()

        // Download original file from GCS
        <span class="cov0" title="0">if err := p.downloadFile(ctx, track.OriginalURL, originalPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("download failed: %v", err)
        }</span>

        // Validate it's a valid audio file
        <span class="cov0" title="0">if err := p.audioProcessor.ValidateAudioFile(ctx, originalPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid audio file: %v", err)
        }</span>

        // Compress with specific options
        <span class="cov0" title="0">if err := p.audioProcessor.CompressAudio(ctx, originalPath, compressedPath, option); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("compression failed: %v", err)
        }</span>

        // Get compressed file info
        <span class="cov0" title="0">compressedInfo, err := os.Stat(compressedPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get compressed file info: %v", err)
        }</span>

        // Upload compressed file to GCS
        <span class="cov0" title="0">compressedObjectName := p.pathConfig.GetCompressedVersionPath(trackID, versionID, option.Format)
        compressedFile, err := os.Open(compressedPath) // #nosec G304 -- Opening controlled temp file for upload
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open compressed file: %v", err)
        }</span>
        <span class="cov0" title="0">defer compressedFile.Close()

        contentType := getContentTypeForFormat(option.Format)
        if err := p.storageService.UploadObject(ctx, compressedObjectName, compressedFile, contentType); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upload compressed file: %v", err)
        }</span>

        <span class="cov0" title="0">compressedURL := p.storageService.GetPublicURL(compressedObjectName)

        // Get actual audio info from compressed file
        actualInfo, err := p.audioProcessor.GetAudioInfo(ctx, compressedPath)
        actualBitrate := option.Bitrate
        actualSampleRate := option.SampleRate
        if actualInfo != nil </span><span class="cov0" title="0">{
                actualBitrate = actualInfo.Bitrate
                actualSampleRate = actualInfo.SampleRate
        }</span>

        // Create compression version record
        <span class="cov0" title="0">version := models.CompressionVersion{
                ID:         versionID,
                URL:        compressedURL,
                Bitrate:    actualBitrate,
                Format:     option.Format,
                Quality:    option.Quality,
                SampleRate: actualSampleRate,
                Size:       compressedInfo.Size(),
                IsPublic:   false, // Default to private, user can make public later
                CreatedAt:  time.Now(),
                Options:    option,
        }

        // Add to track
        if err := p.nostrTrackService.AddCompressionVersion(ctx, trackID, version); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save compression version: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully created compression version %s for track %s", versionID, trackID)
        return nil</span>
}

// getContentTypeForFormat returns the appropriate MIME type for audio formats
func getContentTypeForFormat(format string) string <span class="cov0" title="0">{
        switch format </span>{
        case "mp3":<span class="cov0" title="0">
                return "audio/mpeg"</span>
        case "aac":<span class="cov0" title="0">
                return "audio/aac"</span>
        case "ogg":<span class="cov0" title="0">
                return "audio/ogg"</span>
        default:<span class="cov0" title="0">
                return "audio/mpeg"</span>
        }
}</pre>
		
		<pre class="file" id="file24" style="display: none">package services

import (
        "context"
        "encoding/base64"
        "fmt"
        "io"
        "os"
        "time"

        "cloud.google.com/go/storage"
        "google.golang.org/api/iamcredentials/v1"
        "google.golang.org/api/option"
        "github.com/wavlake/monorepo/internal/config"
)

type StorageService struct {
        client              *storage.Client
        bucketName          string
        serviceAccountEmail string
}

// Make client accessible for direct operations
func (s *StorageService) GetClient() *storage.Client <span class="cov0" title="0">{
        return s.client
}</span>

func (s *StorageService) GetBucketName() string <span class="cov0" title="0">{
        return s.bucketName
}</span>

func NewStorageService(ctx context.Context, bucketName string) (*StorageService, error) <span class="cov0" title="0">{
        // Try to use service account key if available, otherwise use default credentials
        var client *storage.Client
        var err error

        if keyPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS"); keyPath != "" </span><span class="cov0" title="0">{
                client, err = storage.NewClient(ctx, option.WithCredentialsFile(keyPath))
        }</span> else<span class="cov0" title="0"> {
                client, err = storage.NewClient(ctx)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage client: %w", err)
        }</span>

        <span class="cov0" title="0">cfg := config.NewServiceConfig()

        return &amp;StorageService{
                client:              client,
                bucketName:          bucketName,
                serviceAccountEmail: cfg.ServiceAccountEmail,
        }, nil</span>
}

func (s *StorageService) Close() error <span class="cov0" title="0">{
        return s.client.Close()
}</span>

// GeneratePresignedURL creates a presigned URL for uploading files
func (s *StorageService) GeneratePresignedURL(ctx context.Context, objectName string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        // Use the configured service account email
        serviceAccountEmail := s.serviceAccountEmail

        // Generate a presigned URL for PUT operations
        opts := &amp;storage.SignedURLOptions{
                Scheme:         storage.SigningSchemeV4,
                Method:         "PUT",
                Headers:        []string{"Content-Type"},
                Expires:        time.Now().Add(expiration),
                GoogleAccessID: serviceAccountEmail,
                SignBytes: func(b []byte) ([]byte, error) </span><span class="cov0" title="0">{
                        // Use the IAM service to sign the bytes
                        return signBytes(ctx, serviceAccountEmail, b)
                }</span>,
        }

        <span class="cov0" title="0">url, err := s.client.Bucket(s.bucketName).SignedURL(objectName, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}

// GetPublicURL returns the public URL for a storage object
func (s *StorageService) GetPublicURL(objectName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("https://storage.googleapis.com/%s/%s", s.bucketName, objectName)
}</span>

// CopyObject copies an object within the same bucket
func (s *StorageService) CopyObject(ctx context.Context, srcObject, dstObject string) error <span class="cov0" title="0">{
        src := s.client.Bucket(s.bucketName).Object(srcObject)
        dst := s.client.Bucket(s.bucketName).Object(dstObject)

        _, err := dst.CopierFrom(src).Run(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy object: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteObject deletes an object from storage
func (s *StorageService) DeleteObject(ctx context.Context, objectName string) error <span class="cov0" title="0">{
        obj := s.client.Bucket(s.bucketName).Object(objectName)
        if err := obj.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete object: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UploadObject uploads data to storage
func (s *StorageService) UploadObject(ctx context.Context, objectName string, data io.Reader, contentType string) error <span class="cov0" title="0">{
        obj := s.client.Bucket(s.bucketName).Object(objectName)
        writer := obj.NewWriter(ctx)
        writer.ContentType = contentType

        if _, err := io.Copy(writer, data); err != nil </span><span class="cov0" title="0">{
                _ = writer.Close() // #nosec G104 -- Error in cleanup, primary error is more important
                return fmt.Errorf("failed to upload object: %w", err)
        }</span>

        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close writer: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetObjectMetadata returns metadata for an object
func (s *StorageService) GetObjectMetadata(ctx context.Context, objectName string) (interface{}, error) <span class="cov0" title="0">{
        obj := s.client.Bucket(s.bucketName).Object(objectName)
        attrs, err := obj.Attrs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object metadata: %w", err)
        }</span>
        <span class="cov0" title="0">return attrs, nil</span>
}

// GetObjectReader returns a reader for an object
func (s *StorageService) GetObjectReader(ctx context.Context, objectName string) (io.ReadCloser, error) <span class="cov0" title="0">{
        obj := s.client.Bucket(s.bucketName).Object(objectName)
        reader, err := obj.NewReader(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create object reader: %w", err)
        }</span>
        <span class="cov0" title="0">return reader, nil</span>
}

// signBytes uses the Service Account Credentials API to sign bytes with the service account
func signBytes(ctx context.Context, serviceAccountEmail string, bytesToSign []byte) ([]byte, error) <span class="cov0" title="0">{
        // Create IAM Credentials service client
        credentialsService, err := iamcredentials.NewService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create IAM credentials service: %w", err)
        }</span>

        // Prepare the sign request
        <span class="cov0" title="0">resourceName := fmt.Sprintf("projects/-/serviceAccounts/%s", serviceAccountEmail)
        request := &amp;iamcredentials.SignBlobRequest{
                Payload: base64.StdEncoding.EncodeToString(bytesToSign),
        }

        // Sign the bytes
        response, err := credentialsService.Projects.ServiceAccounts.SignBlob(resourceName, request).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign bytes: %w", err)
        }</span>

        // Decode the signature
        <span class="cov0" title="0">signature, err := base64.StdEncoding.DecodeString(response.SignedBlob)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode signature: %w", err)
        }</span>

        <span class="cov0" title="0">return signature, nil</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/wavlake/monorepo/internal/models"
)

// TokenService handles token-based authentication
type TokenService struct {
        // In a real implementation, this would have a database or cache for token storage
        tokens map[string]*models.FileUploadToken
}

// NewTokenService creates a new token service
func NewTokenService() *TokenService <span class="cov0" title="0">{
        return &amp;TokenService{
                tokens: make(map[string]*models.FileUploadToken),
        }
}</span>

// GenerateUploadToken generates a token for file upload
func (s *TokenService) GenerateUploadToken(ctx context.Context, path, userID string, expiration time.Duration) (*models.FileUploadToken, error) <span class="cov0" title="0">{
        // Generate random token
        tokenBytes := make([]byte, 32)
        if _, err := rand.Read(tokenBytes); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>
        
        <span class="cov0" title="0">token := hex.EncodeToString(tokenBytes)
        expiresAt := time.Now().Add(expiration)
        
        uploadToken := &amp;models.FileUploadToken{
                Token:     token,
                ExpiresAt: expiresAt,
                Path:      path,
                UserID:    userID,
                CreatedAt: time.Now(),
        }
        
        // Store token (in a real implementation, this would be in a database or cache)
        s.tokens[token] = uploadToken
        
        return uploadToken, nil</span>
}

// GenerateDeleteToken generates a token for file deletion
func (s *TokenService) GenerateDeleteToken(ctx context.Context, path, userID string, expiration time.Duration) (*models.FileUploadToken, error) <span class="cov0" title="0">{
        // For simplicity, reuse the same structure as upload token
        return s.GenerateUploadToken(ctx, path, userID, expiration)
}</span>

// ValidateToken validates a token for a specific path
func (s *TokenService) ValidateToken(ctx context.Context, token, path string) (*models.FileUploadToken, error) <span class="cov0" title="0">{
        uploadToken, exists := s.tokens[token]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token not found")
        }</span>
        
        // Check if token is expired
        <span class="cov0" title="0">if time.Now().After(uploadToken.ExpiresAt) </span><span class="cov0" title="0">{
                // Clean up expired token
                delete(s.tokens, token)
                return nil, fmt.Errorf("token expired")
        }</span>
        
        // Check if path matches
        <span class="cov0" title="0">if uploadToken.Path != path </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token path mismatch")
        }</span>
        
        <span class="cov0" title="0">return uploadToken, nil</span>
}

// RevokeToken revokes a token
func (s *TokenService) RevokeToken(ctx context.Context, token string) error <span class="cov0" title="0">{
        if _, exists := s.tokens[token]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("token not found")
        }</span>
        
        <span class="cov0" title="0">delete(s.tokens, token)
        return nil</span>
}

// ListActiveTokens lists all active tokens for a user
func (s *TokenService) ListActiveTokens(ctx context.Context, userID string) ([]models.FileUploadToken, error) <span class="cov0" title="0">{
        var activeTokens []models.FileUploadToken
        now := time.Now()
        
        for token, uploadToken := range s.tokens </span><span class="cov0" title="0">{
                if uploadToken.UserID == userID &amp;&amp; now.Before(uploadToken.ExpiresAt) </span><span class="cov0" title="0">{
                        activeTokens = append(activeTokens, *uploadToken)
                }</span> else<span class="cov0" title="0"> if now.After(uploadToken.ExpiresAt) </span><span class="cov0" title="0">{
                        // Clean up expired tokens
                        delete(s.tokens, token)
                }</span>
        }
        
        <span class="cov0" title="0">return activeTokens, nil</span>
}

// RefreshToken refreshes a token with new expiration
func (s *TokenService) RefreshToken(ctx context.Context, token string, expiration time.Duration) (*models.FileUploadToken, error) <span class="cov0" title="0">{
        uploadToken, exists := s.tokens[token]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token not found")
        }</span>
        
        // Check if token is not expired
        <span class="cov0" title="0">if time.Now().After(uploadToken.ExpiresAt) </span><span class="cov0" title="0">{
                delete(s.tokens, token)
                return nil, fmt.Errorf("token expired")
        }</span>
        
        // Update expiration
        <span class="cov0" title="0">uploadToken.ExpiresAt = time.Now().Add(expiration)
        
        return uploadToken, nil</span>
}</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "cloud.google.com/go/firestore"
        "firebase.google.com/go/v4/auth"
        "github.com/wavlake/monorepo/internal/models"
        "google.golang.org/api/iterator"
)

type UserService struct {
        firestoreClient *firestore.Client
        firebaseAuth    *auth.Client
}

func NewUserService(firestoreClient *firestore.Client, firebaseAuth *auth.Client) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                firestoreClient: firestoreClient,
                firebaseAuth:    firebaseAuth,
        }
}</span>

// LinkPubkeyToUser links a Nostr pubkey to a Firebase user
func (s *UserService) LinkPubkeyToUser(ctx context.Context, pubkey, firebaseUID string) error <span class="cov0" title="0">{
        now := time.Now()

        // Check if pubkey is already linked to a different user
        existingAuth, err := s.getNostrAuth(ctx, pubkey)
        if err == nil &amp;&amp; existingAuth.FirebaseUID != firebaseUID &amp;&amp; existingAuth.Active </span><span class="cov0" title="0">{
                return fmt.Errorf("pubkey is already linked to a different user")
        }</span>

        // Start a transaction
        <span class="cov0" title="0">err = s.firestoreClient.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error </span><span class="cov0" title="0">{
                // Create or update User record
                userRef := s.firestoreClient.Collection("users").Doc(firebaseUID)
                userDoc, err := tx.Get(userRef)

                var user models.APIUser
                if err != nil </span><span class="cov0" title="0">{
                        // Create new user
                        user = models.APIUser{
                                FirebaseUID:   firebaseUID,
                                CreatedAt:     now,
                                UpdatedAt:     now,
                                ActivePubkeys: []string{pubkey},
                        }
                }</span> else<span class="cov0" title="0"> {
                        // Update existing user
                        if err := userDoc.DataTo(&amp;user); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse user data: %w", err)
                        }</span>

                        // Add pubkey if not already present
                        <span class="cov0" title="0">if !contains(user.ActivePubkeys, pubkey) </span><span class="cov0" title="0">{
                                user.ActivePubkeys = append(user.ActivePubkeys, pubkey)
                        }</span>
                        <span class="cov0" title="0">user.UpdatedAt = now</span>
                }

                <span class="cov0" title="0">if err := tx.Set(userRef, user); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update user: %w", err)
                }</span>

                // Create or update NostrAuth record
                <span class="cov0" title="0">nostrAuthRef := s.firestoreClient.Collection("nostr_auth").Doc(pubkey)
                nostrAuth := models.NostrAuth{
                        Pubkey:      pubkey,
                        FirebaseUID: firebaseUID,
                        Active:      true,
                        CreatedAt:   now,
                        LastUsedAt:  now,
                        LinkedAt:    now,
                }

                if err := tx.Set(nostrAuthRef, nostrAuth); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create nostr auth: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

// UnlinkPubkeyFromUser unlinks a pubkey from a Firebase user
func (s *UserService) UnlinkPubkeyFromUser(ctx context.Context, pubkey, firebaseUID string) error <span class="cov0" title="0">{
        // Verify the pubkey belongs to this user
        nostrAuth, err := s.getNostrAuth(ctx, pubkey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pubkey not found")
        }</span>

        <span class="cov0" title="0">if nostrAuth.FirebaseUID != firebaseUID </span><span class="cov0" title="0">{
                return fmt.Errorf("pubkey does not belong to this user")
        }</span>

        <span class="cov0" title="0">if !nostrAuth.Active </span><span class="cov0" title="0">{
                return fmt.Errorf("pubkey is already unlinked")
        }</span>

        // Start a transaction
        <span class="cov0" title="0">return s.firestoreClient.RunTransaction(ctx, func(ctx context.Context, tx *firestore.Transaction) error </span><span class="cov0" title="0">{
                // First, get all documents we need to read
                userRef := s.firestoreClient.Collection("users").Doc(firebaseUID)
                userDoc, err := tx.Get(userRef)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get user: %w", err)
                }</span>

                <span class="cov0" title="0">var user models.APIUser
                if err := userDoc.DataTo(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse user data: %w", err)
                }</span>

                // Now perform all writes
                // Update NostrAuth to inactive
                <span class="cov0" title="0">nostrAuthRef := s.firestoreClient.Collection("nostr_auth").Doc(pubkey)
                updatedNostrAuth := nostrAuth
                updatedNostrAuth.Active = false
                if err := tx.Set(nostrAuthRef, updatedNostrAuth); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update nostr auth: %w", err)
                }</span>

                // Update User to remove pubkey from active list
                <span class="cov0" title="0">user.ActivePubkeys = removeString(user.ActivePubkeys, pubkey)
                user.UpdatedAt = time.Now()

                if err := tx.Set(userRef, user); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update user: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

// GetLinkedPubkeys returns all active pubkeys for a Firebase user
func (s *UserService) GetLinkedPubkeys(ctx context.Context, firebaseUID string) ([]models.NostrAuth, error) <span class="cov0" title="0">{
        // Try simple query first (without OrderBy) in case indexes are missing
        query := s.firestoreClient.Collection("nostr_auth").
                Where("firebase_uid", "==", firebaseUID).
                Where("active", "==", true)

        // Try with OrderBy first, fall back to simple query if it fails
        orderedQuery := query.OrderBy("linked_at", firestore.Asc)

        iter := orderedQuery.Documents(ctx)
        defer iter.Stop()

        var pubkeys []models.NostrAuth
        for </span><span class="cov0" title="0">{
                doc, err := iter.Next()
                if err == iterator.Done </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        // If the ordered query fails (likely due to missing index), try simple query
                        iter.Stop()
                        simpleIter := query.Documents(ctx)
                        defer simpleIter.Stop()

                        for </span><span class="cov0" title="0">{
                                doc, err := simpleIter.Next()
                                if err == iterator.Done </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to query pubkeys (both ordered and simple): %w", err)
                                }</span>

                                <span class="cov0" title="0">var nostrAuth models.NostrAuth
                                if err := doc.DataTo(&amp;nostrAuth); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to parse nostr auth: %w", err)
                                }</span>

                                <span class="cov0" title="0">pubkeys = append(pubkeys, nostrAuth)</span>
                        }
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">var nostrAuth models.NostrAuth
                if err := doc.DataTo(&amp;nostrAuth); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse nostr auth: %w", err)
                }</span>

                <span class="cov0" title="0">pubkeys = append(pubkeys, nostrAuth)</span>
        }

        <span class="cov0" title="0">return pubkeys, nil</span>
}

// GetFirebaseUIDByPubkey returns the Firebase UID for a given pubkey if it's linked and active
func (s *UserService) GetFirebaseUIDByPubkey(ctx context.Context, pubkey string) (string, error) <span class="cov0" title="0">{
        nostrAuth, err := s.getNostrAuth(ctx, pubkey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("pubkey not found: %w", err)
        }</span>

        <span class="cov0" title="0">if !nostrAuth.Active </span><span class="cov0" title="0">{
                return "", fmt.Errorf("pubkey is not active")
        }</span>

        <span class="cov0" title="0">return nostrAuth.FirebaseUID, nil</span>
}

// getNostrAuth retrieves a NostrAuth record by pubkey
func (s *UserService) getNostrAuth(ctx context.Context, pubkey string) (*models.NostrAuth, error) <span class="cov0" title="0">{
        doc, err := s.firestoreClient.Collection("nostr_auth").Doc(pubkey).Get(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var nostrAuth models.NostrAuth
        if err := doc.DataTo(&amp;nostrAuth); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;nostrAuth, nil</span>
}

// Helper functions
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func removeString(slice []string, item string) []string <span class="cov0" title="0">{
        var result []string
        for _, s := range slice </span><span class="cov0" title="0">{
                if s != item </span><span class="cov0" title="0">{
                        result = append(result, s)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// GetUserEmail retrieves the email address for a Firebase user
func (s *UserService) GetUserEmail(ctx context.Context, firebaseUID string) (string, error) <span class="cov0" title="0">{
        user, err := s.firebaseAuth.GetUser(ctx, firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user from Firebase Auth: %w", err)
        }</span>

        <span class="cov0" title="0">return user.Email, nil</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "context"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/wavlake/monorepo/internal/models"
)

// WebhookService handles webhook processing
type WebhookService struct {
        processingService ProcessingServiceInterface
        nostrTrackService NostrTrackServiceInterface
}

// NewWebhookService creates a new webhook service
func NewWebhookService(processingService ProcessingServiceInterface, nostrTrackService NostrTrackServiceInterface) *WebhookService <span class="cov0" title="0">{
        return &amp;WebhookService{
                processingService: processingService,
                nostrTrackService: nostrTrackService,
        }
}</span>

// ProcessCloudFunctionWebhook processes webhooks from Cloud Functions
func (s *WebhookService) ProcessCloudFunctionWebhook(ctx context.Context, payload models.WebhookPayload) error <span class="cov0" title="0">{
        switch payload.EventType </span>{
        case "track.processed":<span class="cov0" title="0">
                // Handle track processing completion
                if trackID, ok := payload.Data["track_id"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleTrackProcessed(ctx, trackID, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing track_id in payload")</span>
                
        case "compression.completed":<span class="cov0" title="0">
                // Handle compression completion
                if trackID, ok := payload.Data["track_id"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleCompressionCompleted(ctx, trackID, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing track_id in payload")</span>
                
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported event type: %s", payload.EventType)</span>
        }
}

// ProcessStorageWebhook processes webhooks from storage events
func (s *WebhookService) ProcessStorageWebhook(ctx context.Context, payload models.WebhookPayload) error <span class="cov0" title="0">{
        switch payload.EventType </span>{
        case "object.upload":<span class="cov0" title="0">
                // Handle file upload events
                if objectName, ok := payload.Data["object_name"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleFileUploaded(ctx, objectName, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing object_name in payload")</span>
                
        case "object.delete":<span class="cov0" title="0">
                // Handle file deletion events
                if objectName, ok := payload.Data["object_name"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleFileDeleted(ctx, objectName, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing object_name in payload")</span>
                
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported storage event type: %s", payload.EventType)</span>
        }
}

// ProcessNostrRelayWebhook processes webhooks from Nostr relay events
func (s *WebhookService) ProcessNostrRelayWebhook(ctx context.Context, payload models.WebhookPayload) error <span class="cov0" title="0">{
        switch payload.EventType </span>{
        case "event.published":<span class="cov0" title="0">
                // Handle Nostr event publication
                if eventID, ok := payload.Data["event_id"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleNostrEventPublished(ctx, eventID, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing event_id in payload")</span>
                
        case "event.deleted":<span class="cov0" title="0">
                // Handle Nostr event deletion
                if eventID, ok := payload.Data["event_id"].(string); ok </span><span class="cov0" title="0">{
                        return s.handleNostrEventDeleted(ctx, eventID, payload.Data)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("missing event_id in payload")</span>
                
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported Nostr event type: %s", payload.EventType)</span>
        }
}

// GetWebhookStatus returns the status of a webhook
func (s *WebhookService) GetWebhookStatus(ctx context.Context, webhookID string) (*models.ProcessingStatus, error) <span class="cov0" title="0">{
        // In a real implementation, this would query a database for webhook status
        return &amp;models.ProcessingStatus{
                TrackID:     webhookID,
                Status:      "completed",
                Progress:    100,
                Message:     "Webhook processed successfully",
                StartedAt:   time.Now().Add(-5 * time.Minute),
                CompletedAt: time.Now(),
        }, nil
}</span>

// RetryFailedWebhooks retries failed webhooks
func (s *WebhookService) RetryFailedWebhooks(ctx context.Context, maxRetries int) error <span class="cov0" title="0">{
        // In a real implementation, this would:
        // - Query failed webhooks from database
        // - Retry processing up to maxRetries times
        // - Update webhook status
        
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxRetries must be positive")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ValidateWebhookSignature validates HMAC signature for webhook security
func (s *WebhookService) ValidateWebhookSignature(payload []byte, signature, secret string) error <span class="cov0" title="0">{
        if secret == "" </span><span class="cov0" title="0">{
                return nil // Skip validation if no secret configured
        }</span>

        // Calculate expected signature
        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        expectedSignature := hex.EncodeToString(mac.Sum(nil))

        // Compare signatures
        if !hmac.Equal([]byte(signature), []byte(expectedSignature)) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid webhook signature")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods for handling specific webhook events

func (s *WebhookService) handleTrackProcessed(ctx context.Context, trackID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // Update track as processed
        updates := map[string]interface{}{
                "is_processing": false,
        }
        
        if size, ok := data["size"].(float64); ok </span><span class="cov0" title="0">{
                updates["size"] = int64(size)
        }</span>
        
        <span class="cov0" title="0">if duration, ok := data["duration"].(float64); ok </span><span class="cov0" title="0">{
                updates["duration"] = int(duration)
        }</span>
        
        <span class="cov0" title="0">return s.nostrTrackService.UpdateTrack(ctx, trackID, updates)</span>
}

func (s *WebhookService) handleCompressionCompleted(ctx context.Context, trackID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // In a real implementation, this would add the compression version to the track
        _ = trackID
        _ = data
        return nil
}</span>

func (s *WebhookService) handleFileUploaded(ctx context.Context, objectName string, data map[string]interface{}) error <span class="cov0" title="0">{
        // In a real implementation, this might trigger processing
        _ = objectName
        _ = data
        return nil
}</span>

func (s *WebhookService) handleFileDeleted(ctx context.Context, objectName string, data map[string]interface{}) error <span class="cov0" title="0">{
        // In a real implementation, this might clean up related records
        _ = objectName
        _ = data
        return nil
}</span>

func (s *WebhookService) handleNostrEventPublished(ctx context.Context, eventID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // In a real implementation, this might update track status
        _ = eventID
        _ = data
        return nil
}</span>

func (s *WebhookService) handleNostrEventDeleted(ctx context.Context, eventID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // In a real implementation, this might mark track as deleted
        _ = eventID
        _ = data
        return nil
}</pre>
		
		<pre class="file" id="file28" style="display: none">package utils

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/wavlake/monorepo/internal/models"
)

// AudioProcessor handles audio file processing and compression
type AudioProcessor struct {
        tempDir string
}

// NewAudioProcessor creates a new audio processor
func NewAudioProcessor(tempDir string) *AudioProcessor <span class="cov0" title="0">{
        return &amp;AudioProcessor{
                tempDir: tempDir,
        }
}</span>

// AudioInfo contains metadata about an audio file
type AudioInfo struct {
        Duration   int   // Duration in seconds
        Size       int64 // File size in bytes
        Bitrate    int   // Bitrate in kbps
        SampleRate int   // Sample rate in Hz
        Channels   int   // Number of channels
}

// GetAudioInfo extracts metadata from an audio file using ffprobe
func (ap *AudioProcessor) GetAudioInfo(ctx context.Context, inputPath string) (*AudioInfo, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "ffprobe",
                "-v", "quiet",
                "-show_entries", "format=duration,size,bit_rate",
                "-show_entries", "stream=sample_rate,channels",
                "-of", "csv=p=0",
                inputPath)

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get audio info: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        if len(lines) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected ffprobe output format")
        }</span>

        // Parse format info (duration, size, bit_rate)
        <span class="cov0" title="0">formatParts := strings.Split(lines[0], ",")
        if len(formatParts) &lt; 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected format info format")
        }</span>

        <span class="cov0" title="0">duration, err := strconv.ParseFloat(formatParts[0], 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse duration: %w", err)
        }</span>

        <span class="cov0" title="0">size, err := strconv.ParseInt(formatParts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse size: %w", err)
        }</span>

        <span class="cov0" title="0">bitrate, err := strconv.ParseInt(formatParts[2], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                // Bitrate might be N/A, calculate from size and duration
                if duration &gt; 0 &amp;&amp; size &gt; 0 </span><span class="cov0" title="0">{
                        bitrate = int64((float64(size) * 8) / (duration * 1000))
                }</span>
        }

        // Parse stream info (sample_rate, channels)
        <span class="cov0" title="0">streamParts := strings.Split(lines[1], ",")
        if len(streamParts) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected stream info format")
        }</span>

        <span class="cov0" title="0">sampleRate, err := strconv.Atoi(streamParts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse sample rate: %w", err)
        }</span>

        <span class="cov0" title="0">channels, err := strconv.Atoi(streamParts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse channels: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AudioInfo{
                Duration:   int(duration),
                Size:       size,
                Bitrate:    int(bitrate),
                SampleRate: sampleRate,
                Channels:   channels,
        }, nil</span>
}

// CompressAudio compresses audio with user-specified options (interface method)
func (ap *AudioProcessor) CompressAudio(ctx context.Context, inputPath, outputPath string, options models.CompressionOption) error <span class="cov0" title="0">{
        return ap.CompressAudioWithOptions(ctx, inputPath, outputPath, options)
}</span>

// CompressAudioDefault compresses an audio file to a reasonable streaming quality
// Target: 128kbps MP3, 44.1kHz sample rate
func (ap *AudioProcessor) CompressAudioDefault(ctx context.Context, inputPath, outputPath string) error <span class="cov0" title="0">{
        // Create output directory if it doesn't exist
        // #nosec G301
        if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Use ffmpeg to compress the audio
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "ffmpeg",
                "-i", inputPath,
                "-codec:a", "libmp3lame", // Use LAME MP3 encoder
                "-b:a", "128k", // 128 kbps bitrate
                "-ar", "44100", // 44.1 kHz sample rate
                "-ac", "2", // Stereo (2 channels)
                "-f", "mp3", // Output format
                "-y", // Overwrite output file
                outputPath)

        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress audio: %w, output: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully compressed audio: %s -&gt; %s", inputPath, outputPath)
        return nil</span>
}

// DownloadAndCompress downloads an audio file from a URL and compresses it
func (ap *AudioProcessor) DownloadAndCompress(ctx context.Context, sourceURL, outputPath string) (*AudioInfo, error) <span class="cov0" title="0">{
        // Create temporary file for download
        tempFile, err := os.CreateTemp(ap.tempDir, "audio_download_*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tempFile.Name())
        defer tempFile.Close()

        // Download the file using curl (more reliable than Go's http client for large files)
        cmd := exec.CommandContext(ctx, "curl", // #nosec G204 -- Curl execution with controlled args for file download
                "-L",                  // Follow redirects
                "-o", tempFile.Name(), // Output to temp file
                sourceURL)

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to download audio file: %w", err)
        }</span>

        // Get info about the original file
        <span class="cov0" title="0">audioInfo, err := ap.GetAudioInfo(ctx, tempFile.Name())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get audio info: %w", err)
        }</span>

        // Compress the audio
        <span class="cov0" title="0">if err := ap.CompressAudioDefault(ctx, tempFile.Name(), outputPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to compress audio: %w", err)
        }</span>

        <span class="cov0" title="0">return audioInfo, nil</span>
}

// ValidateAudioFile checks if a file is a valid audio file
func (ap *AudioProcessor) ValidateAudioFile(ctx context.Context, filePath string) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "ffprobe",
                "-v", "error",
                "-select_streams", "a:0",
                "-show_entries", "stream=codec_type",
                "-of", "csv=p=0",
                filePath)

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file is not a valid audio file: %w", err)
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(string(output)) != "audio" </span><span class="cov0" title="0">{
                return fmt.Errorf("file does not contain audio stream")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetSupportedFormats returns a list of supported audio formats
func (ap *AudioProcessor) GetSupportedFormats() []string <span class="cov0" title="0">{
        return []string{
                "mp3", "wav", "flac", "aac", "ogg", "m4a", "wma", "aiff", "au",
        }
}</span>

// IsFormatSupported checks if an audio format is supported
func (ap *AudioProcessor) IsFormatSupported(extension string) bool <span class="cov0" title="0">{
        extension = strings.ToLower(strings.TrimPrefix(extension, "."))
        for _, format := range ap.GetSupportedFormats() </span><span class="cov0" title="0">{
                if format == extension </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CompressAudioWithOptions compresses audio with specific user-defined options
func (ap *AudioProcessor) CompressAudioWithOptions(ctx context.Context, inputPath, outputPath string, options models.CompressionOption) error <span class="cov0" title="0">{
        log.Printf("Compressing audio with options: %+v", options)

        // Build ffmpeg command based on format and options
        args := []string{
                "-i", inputPath,
                "-y", // Overwrite output file
        }

        // Add format-specific encoding options
        switch options.Format </span>{
        case "mp3":<span class="cov0" title="0">
                args = append(args, "-c:a", "libmp3lame")
                args = append(args, "-b:a", fmt.Sprintf("%dk", options.Bitrate))</span>
        case "aac":<span class="cov0" title="0">
                args = append(args, "-c:a", "aac")
                args = append(args, "-b:a", fmt.Sprintf("%dk", options.Bitrate))</span>
        case "ogg":<span class="cov0" title="0">
                args = append(args, "-c:a", "libvorbis")
                args = append(args, "-b:a", fmt.Sprintf("%dk", options.Bitrate))</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s", options.Format)</span>
        }

        // Add sample rate if specified
        <span class="cov0" title="0">if options.SampleRate &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "-ar", fmt.Sprintf("%d", options.SampleRate))
        }</span>

        // Add quality settings based on quality level
        <span class="cov0" title="0">switch options.Quality </span>{
        case "low":<span class="cov0" title="0">
                args = append(args, "-q:a", "9")</span> // Lower quality, smaller file
        case "medium":<span class="cov0" title="0">
                args = append(args, "-q:a", "5")</span> // Balanced
        case "high":<span class="cov0" title="0">
                args = append(args, "-q:a", "1")</span> // Higher quality, larger file
        }

        // Add output path
        <span class="cov0" title="0">args = append(args, outputPath)

        // Execute ffmpeg
        cmd := exec.CommandContext(ctx, "ffmpeg", args...) // #nosec G204 -- FFmpeg execution with controlled args for audio processing
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compress audio with options %+v: %w, output: %s", options, err, string(output))
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully compressed audio with options: %s -&gt; %s", inputPath, outputPath)
        return nil</span>
}

// ExtractMetadata extracts comprehensive metadata from an audio file
func (ap *AudioProcessor) ExtractMetadata(ctx context.Context, filePath string) (*models.AudioMetadata, error) <span class="cov0" title="0">{
        // Get basic audio info
        audioInfo, err := ap.GetAudioInfo(ctx, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get audio info: %w", err)
        }</span>

        // Get format info
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "ffprobe",
                "-v", "quiet",
                "-show_entries", "format=format_name",
                "-show_entries", "format_tags=title,artist,album,genre,date,track",
                "-of", "csv=p=0",
                filePath)

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If metadata extraction fails, return basic info
                return &amp;models.AudioMetadata{
                        Duration:   audioInfo.Duration,
                        Bitrate:    audioInfo.Bitrate,
                        SampleRate: audioInfo.SampleRate,
                        Channels:   audioInfo.Channels,
                        Format:     "unknown",
                }, nil
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        
        metadata := &amp;models.AudioMetadata{
                Duration:   audioInfo.Duration,
                Bitrate:    audioInfo.Bitrate,
                SampleRate: audioInfo.SampleRate,
                Channels:   audioInfo.Channels,
                Tags:       make(map[string]string),
        }

        // Parse format and tags
        if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                formatParts := strings.Split(lines[0], ",")
                if len(formatParts) &gt; 0 </span><span class="cov0" title="0">{
                        metadata.Format = formatParts[0]
                }</span>
                
                // Parse metadata tags if available
                <span class="cov0" title="0">if len(formatParts) &gt; 1 </span><span class="cov0" title="0">{
                        tags := formatParts[1:]
                        tagNames := []string{"title", "artist", "album", "genre", "date", "track"}
                        
                        for i, tag := range tags </span><span class="cov0" title="0">{
                                if i &lt; len(tagNames) &amp;&amp; tag != "" </span><span class="cov0" title="0">{
                                        switch tagNames[i] </span>{
                                        case "title":<span class="cov0" title="0">
                                                metadata.Title = tag</span>
                                        case "artist":<span class="cov0" title="0">
                                                metadata.Artist = tag</span>
                                        case "album":<span class="cov0" title="0">
                                                metadata.Album = tag</span>
                                        case "genre":<span class="cov0" title="0">
                                                metadata.Genre = tag</span>
                                        case "date":<span class="cov0" title="0">
                                                if year, err := strconv.Atoi(tag); err == nil </span><span class="cov0" title="0">{
                                                        metadata.Year = year
                                                }</span>
                                        case "track":<span class="cov0" title="0">
                                                if track, err := strconv.Atoi(tag); err == nil </span><span class="cov0" title="0">{
                                                        metadata.TrackNumber = track
                                                }</span>
                                        }
                                        <span class="cov0" title="0">metadata.Tags[tagNames[i]] = tag</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return metadata, nil</span>
}

</pre>
		
		<pre class="file" id="file29" style="display: none">package utils

import (
        "fmt"
)

// StoragePathConfig holds path configuration for different storage providers
type StoragePathConfig struct {
        OriginalPrefix   string
        CompressedPrefix string
        UseLegacyPaths   bool
}

// GetStoragePathConfig returns a fixed path configuration for GCS storage.
// The paths are set to standard prefixes: 'tracks/original' and 'tracks/compressed'.

func GetStoragePathConfig() *StoragePathConfig <span class="cov0" title="0">{
        config := &amp;StoragePathConfig{
                OriginalPrefix:   "tracks/original",
                CompressedPrefix: "tracks/compressed",
                UseLegacyPaths:   false,
        }

        return config
}</span>

// GetOriginalPath returns the storage path for original uploaded files
func (c *StoragePathConfig) GetOriginalPath(trackID, extension string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s.%s", c.OriginalPrefix, trackID, extension)
}</span>

// GetCompressedPath returns the storage path for compressed files
func (c *StoragePathConfig) GetCompressedPath(trackID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s.mp3", c.CompressedPrefix, trackID)
}</span>

// GetCompressedVersionPath returns the storage path for specific compression versions
func (c *StoragePathConfig) GetCompressedVersionPath(trackID, versionID, format string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s_%s.%s", c.CompressedPrefix, trackID, versionID, format)
}</span>

// IsOriginalPath checks if a given path is in the original files directory
func (c *StoragePathConfig) IsOriginalPath(objectPath string) bool <span class="cov0" title="0">{
        expectedPrefix := c.OriginalPrefix + "/"
        return len(objectPath) &gt; len(expectedPrefix) &amp;&amp; objectPath[:len(expectedPrefix)] == expectedPrefix
}</span>

// IsCompressedPath checks if a given path is in the compressed files directory
func (c *StoragePathConfig) IsCompressedPath(objectPath string) bool <span class="cov0" title="0">{
        expectedPrefix := c.CompressedPrefix + "/"
        return len(objectPath) &gt; len(expectedPrefix) &amp;&amp; objectPath[:len(expectedPrefix)] == expectedPrefix
}</span>

// GetTrackIDFromPath extracts track ID from a storage path
func (c *StoragePathConfig) GetTrackIDFromPath(objectPath string) string <span class="cov0" title="0">{
        var prefix string
        if c.IsOriginalPath(objectPath) </span><span class="cov0" title="0">{
                prefix = c.OriginalPrefix + "/"
        }</span> else<span class="cov0" title="0"> if c.IsCompressedPath(objectPath) </span><span class="cov0" title="0">{
                prefix = c.CompressedPrefix + "/"
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>

        // Extract filename without path
        <span class="cov0" title="0">filename := objectPath[len(prefix):]

        // Extract track ID (everything before first dot)
        for i, char := range filename </span><span class="cov0" title="0">{
                if char == '.' </span><span class="cov0" title="0">{
                        return filename[:i]
                }</span>
                <span class="cov0" title="0">if char == '_' </span><span class="cov0" title="0">{
                        // For versioned compressed files, track ID is before underscore
                        return filename[:i]
                }</span>
        }

        <span class="cov0" title="0">return filename</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
